# GitHub Actions workflow for deploying Laravel application to AWS
# This workflow builds and deploys the Laravel application to AWS using CDK

name: Deploy Laravel Application

# Trigger the workflow manually with environment selection
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

# Define the deployment job
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      # Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Configure AWS credentials for deployment
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Set up Node.js for CDK deployment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Install CDK and infrastructure dependencies
      - name: Install dependencies
        working-directory: infrastructure
        run: |
          npm install
          npm install -g aws-cdk

      # Set environment variables for deployment
      - name: Set environment variables
        run: |
          # Set AWS account and region
          echo "CDK_DEFAULT_ACCOUNT=${{ secrets.AWS_ACCOUNT_ID }}" >> $GITHUB_ENV
          echo "CDK_DEFAULT_REGION=${{ secrets.AWS_REGION }}" >> $GITHUB_ENV
          
          # Set deployment environment
          echo "ENVIRONMENT=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          
          # Set database credentials
          echo "DB_USERNAME=${{ secrets.DB_USERNAME }}" >> $GITHUB_ENV
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> $GITHUB_ENV
          
          # Generate a random APP_KEY if not provided
          if [ -z "${{ secrets.APP_KEY }}" ]; then
            echo "APP_KEY=$(openssl rand -base64 32)" >> $GITHUB_ENV
          else
            echo "APP_KEY=${{ secrets.APP_KEY }}" >> $GITHUB_ENV
          fi
          
          # Display environment variables (without sensitive values)
          echo "Environment variables set:"
          echo "CDK_DEFAULT_ACCOUNT: ${{ secrets.AWS_ACCOUNT_ID }}"
          echo "CDK_DEFAULT_REGION: ${{ secrets.AWS_REGION }}"
          echo "ENVIRONMENT: ${{ github.event.inputs.environment }}"
          echo "DB_USERNAME: ${{ secrets.DB_USERNAME }}"
          echo "APP_KEY: [REDACTED]"

      # Create and verify AWS Parameter Store parameters
      - name: Create and verify AWS Parameter Store parameters
        run: |
          # Create the parameter with the correct path based on environment
          PARAM_NAME="/${CDK_DEFAULT_ACCOUNT}/prod/APP_KEY"
          echo "Creating parameter: $PARAM_NAME"
          
          # Store the APP_KEY in AWS Parameter Store
          aws ssm put-parameter \
            --name "$PARAM_NAME" \
            --value "$APP_KEY" \
            --type "String" \
            --overwrite
          
          # Verify parameter was created
          echo "Verifying parameter exists..."
          aws ssm get-parameter --name "$PARAM_NAME" --with-decryption
          
          # List parameters to confirm
          echo "Listing parameters in path: /${CDK_DEFAULT_ACCOUNT}/prod/"
          aws ssm get-parameters-by-path --path "/${CDK_DEFAULT_ACCOUNT}/prod/" --recursive
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CDK_DEFAULT_ACCOUNT: ${{ env.CDK_DEFAULT_ACCOUNT }}
          APP_KEY: ${{ env.APP_KEY }}

      # Bootstrap CDK environment
      - name: Bootstrap CDK environment
        working-directory: infrastructure
        run: |
          echo "Bootstrapping CDK environment..."
          npm run bootstrap -- --require-approval never
          
          # Verify bootstrap completed
          echo "Verifying bootstrap status..."
          aws cloudformation describe-stacks --stack-name CDKToolkit --query 'Stacks[0].StackStatus' --output text
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CDK_DEFAULT_ACCOUNT: ${{ env.CDK_DEFAULT_ACCOUNT }}
          CDK_DEFAULT_REGION: ${{ env.CDK_DEFAULT_REGION }}

      # Build and push Docker images to ECR
      - name: Build and push Docker images
        run: |
          # Login to ECR
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com
          
          # Build and push PHP-FPM image
          docker build -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/laravel-app:${{ github.sha }} .
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/laravel-app:${{ github.sha }}
          
          # Verify PHP-FPM image was pushed
          echo "Verifying PHP-FPM image was pushed..."
          aws ecr describe-images --repository-name laravel-app --image-ids imageTag=${{ github.sha }} || { echo "PHP-FPM image not found"; exit 1; }
          
          # Build and push Nginx image
          docker build -f nginx.Dockerfile -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/laravel-nginx:${{ github.sha }} .
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/laravel-nginx:${{ github.sha }}
          
          # Verify Nginx image was pushed
          echo "Verifying Nginx image was pushed..."
          aws ecr describe-images --repository-name laravel-nginx --image-ids imageTag=${{ github.sha }} || { echo "Nginx image not found"; exit 1; }

      # Deploy infrastructure using CDK
      - name: Deploy infrastructure
        id: deploy
        working-directory: infrastructure
        run: |
          echo "Deploying infrastructure..."
          npm run deploy -- --require-approval never
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          CDK_DEFAULT_ACCOUNT: ${{ env.CDK_DEFAULT_ACCOUNT }}
          CDK_DEFAULT_REGION: ${{ env.CDK_DEFAULT_REGION }}
          DB_USERNAME: ${{ env.DB_USERNAME }}
          DB_PASSWORD: ${{ env.DB_PASSWORD }}
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          GITHUB_SHA: ${{ github.sha }}

      # Check deployment status and rollback if needed
      - name: Check deployment status
        if: failure() && steps.deploy.outcome == 'failure'
        run: |
          echo "Deployment failed. Checking stack status..."
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name LaravelStack --query 'Stacks[0].StackStatus' --output text)
          echo "Stack status: $STACK_STATUS"
          
          # Wait for stack operations to complete before attempting rollback
          if [[ "$STACK_STATUS" == "CREATE_IN_PROGRESS" || "$STACK_STATUS" == "UPDATE_IN_PROGRESS" ]]; then
            echo "Stack is still in progress. Waiting for it to complete before attempting rollback..."
            aws cloudformation wait stack-create-complete --stack-name LaravelStack || true
            aws cloudformation wait stack-update-complete --stack-name LaravelStack || true
          fi
          
          # Attempt to destroy the stack to rollback changes
          echo "Attempting to destroy the stack..."
          cd infrastructure && npm run destroy -- --force || echo "Failed to destroy stack. Manual intervention may be required."

      # Update ECS services to use the new images
      - name: Update ECS service
        if: success() || failure()
        run: |
          aws ecs update-service --cluster LaravelCluster --service LaravelNginxService --force-new-deployment
          aws ecs update-service --cluster LaravelCluster --service LaravelPhpService --force-new-deployment

      # Wait for services to stabilize and verify application health
      - name: Wait for services to stabilize
        run: |
          echo "Waiting for services to stabilize..."
          sleep 60
          
          # Get the ALB DNS name
          ALB_DNS=$(aws cloudformation describe-stacks --stack-name LaravelStack --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' --output text)
          echo "ALB DNS: $ALB_DNS"
          
          # Wait for the ALB to be ready
          echo "Waiting for ALB to be ready..."
          aws elbv2 wait load-balancer-available --load-balancers $(aws elbv2 describe-load-balancers --names LaravelALB --query 'LoadBalancers[0].LoadBalancerArn' --output text)
          
          # Check if the application is responding
          echo "Checking if the application is responding..."
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS)
            echo "HTTP Status: $HTTP_STATUS"
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "Application is responding with 200 OK"
              exit 0
            fi
            echo "Attempt $i: Application not ready yet, waiting 30 seconds..."
            sleep 30
          done
          
          echo "Application failed to respond with 200 OK after 10 attempts"
          exit 1 