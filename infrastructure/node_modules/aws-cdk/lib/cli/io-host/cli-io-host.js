"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliIoHost = void 0;
exports.isCI = isCI;
const util = require("node:util");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const chalk = require("chalk");
const promptly = require("promptly");
const api_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const deploy_1 = require("../../commands/deploy");
const activity_printer_1 = require("../activity-printer");
/**
 * A simple IO host for the CLI that writes messages to the console.
 */
class CliIoHost {
    /**
     * Returns the singleton instance
     */
    static instance(props = {}, forceNew = false) {
        if (forceNew || !CliIoHost._instance) {
            CliIoHost._instance = new CliIoHost(props);
        }
        return CliIoHost._instance;
    }
    constructor(props = {}) {
        /**
         * Configure the target stream for notices
         *
         * (Not a setter because there's no need for additional logic when this value
         * is changed yet)
         */
        this.noticesDestination = 'stderr';
        this._progress = deploy_1.StackActivityProgress.BAR;
        // Corked Logging
        this.corkedCounter = 0;
        this.corkedLoggingBuffer = [];
        this.currentAction = props.currentAction ?? 'none';
        this.isTTY = props.isTTY ?? process.stdout.isTTY ?? false;
        this.logLevel = props.logLevel ?? 'info';
        this.isCI = props.isCI ?? isCI();
        this.requireDeployApproval = props.requireDeployApproval ?? cloud_assembly_schema_1.RequireApproval.BROADENING;
        this.stackProgress = props.stackProgress ?? deploy_1.StackActivityProgress.BAR;
    }
    /**
     * Returns the singleton instance
     */
    registerIoHost(ioHost) {
        if (ioHost !== this) {
            this._internalIoHost = ioHost;
        }
    }
    /**
     * Update the stackProgress preference.
     */
    set stackProgress(type) {
        this._progress = type;
    }
    /**
     * Gets the stackProgress value.
     *
     * This takes into account other state of the ioHost,
     * like if isTTY and isCI.
     */
    get stackProgress() {
        // We can always use EVENTS
        if (this._progress === deploy_1.StackActivityProgress.EVENTS) {
            return this._progress;
        }
        // if a debug message (and thus any more verbose messages) are relevant to the current log level, we have verbose logging
        const verboseLogging = (0, private_1.isMessageRelevantForLevel)({ level: 'debug' }, this.logLevel);
        if (verboseLogging) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On Windows we cannot use fancy output
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On some CI systems (such as CircleCI) output still reports as a TTY so we also
        // need an individual check for whether we're running on CI.
        // see: https://discuss.circleci.com/t/circleci-terminal-is-a-tty-but-term-is-not-set/9965
        const fancyOutputAvailable = this.isTTY && !this.isCI;
        if (!fancyOutputAvailable) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // Use the user preference
        return this._progress;
    }
    get defaults() {
        return new private_1.IoDefaultMessages(this.asIoHelper());
    }
    asIoHelper() {
        return (0, private_1.asIoHelper)(this, this.currentAction);
    }
    /**
     * Executes a block of code with corked logging. All log messages during execution
     * are buffered and only written when all nested cork blocks complete (when CORK_COUNTER reaches 0).
     * The corking is bound to the specific instance of the CliIoHost.
     *
     * @param block - Async function to execute with corked logging
     * @returns Promise that resolves with the block's return value
     */
    async withCorkedLogging(block) {
        this.corkedCounter++;
        try {
            return await block();
        }
        finally {
            this.corkedCounter--;
            if (this.corkedCounter === 0) {
                // Process each buffered message through notify
                for (const ioMessage of this.corkedLoggingBuffer) {
                    await this.notify(ioMessage);
                }
                // remove all buffered messages in-place
                this.corkedLoggingBuffer.splice(0);
            }
        }
    }
    /**
     * Notifies the host of a message.
     * The caller waits until the notification completes.
     */
    async notify(msg) {
        if (this._internalIoHost) {
            return this._internalIoHost.notify(msg);
        }
        if (this.isStackActivity(msg)) {
            if (!this.activityPrinter) {
                this.activityPrinter = this.makeActivityPrinter();
            }
            await this.activityPrinter.notify(msg);
            return;
        }
        if (!(0, private_1.isMessageRelevantForLevel)(msg, this.logLevel)) {
            return;
        }
        if (this.corkedCounter > 0) {
            this.corkedLoggingBuffer.push(msg);
            return;
        }
        const output = this.formatMessage(msg);
        const stream = this.selectStream(msg);
        stream?.write(output);
    }
    /**
     * Detect stack activity messages so they can be send to the printer.
     */
    isStackActivity(msg) {
        return [
            'CDK_TOOLKIT_I5501',
            'CDK_TOOLKIT_I5502',
            'CDK_TOOLKIT_I5503',
        ].includes(msg.code);
    }
    /**
     * Detect special messages encode information about whether or not
     * they require approval
     */
    skipApprovalStep(msg) {
        const approvalToolkitCodes = ['CDK_TOOLKIT_I5060'];
        if (!approvalToolkitCodes.includes(msg.code)) {
            false;
        }
        switch (this.requireDeployApproval) {
            // Never require approval
            case cloud_assembly_schema_1.RequireApproval.NEVER:
                return true;
            // Always require approval
            case cloud_assembly_schema_1.RequireApproval.ANYCHANGE:
                return false;
            // Require approval if changes include broadening permissions
            case cloud_assembly_schema_1.RequireApproval.BROADENING:
                return ['none', 'non-broadening'].includes(msg.data?.permissionChangeType);
        }
    }
    /**
     * Determines the output stream, based on message and configuration.
     */
    selectStream(msg) {
        if (isNoticesMessage(msg)) {
            return targetStreamObject(this.noticesDestination);
        }
        return this.selectStreamFromLevel(msg.level);
    }
    /**
     * Determines the output stream, based on message level and configuration.
     */
    selectStreamFromLevel(level) {
        // The stream selection policy for the CLI is the following:
        //
        //   (1) Messages of level `result` always go to `stdout`
        //   (2) Messages of level `error` always go to `stderr`.
        //   (3a) All remaining messages go to `stderr`.
        //   (3b) If we are in CI mode, all remaining messages go to `stdout`.
        //
        switch (level) {
            case 'error':
                return process.stderr;
            case 'result':
                return process.stdout;
            default:
                return this.isCI ? process.stdout : process.stderr;
        }
    }
    /**
     * Notifies the host of a message that requires a response.
     *
     * If the host does not return a response the suggested
     * default response from the input message will be used.
     */
    async requestResponse(msg) {
        // First call out to a registered instance if we have one
        if (this._internalIoHost) {
            return this._internalIoHost.requestResponse(msg);
        }
        // If the request cannot be prompted for by the CliIoHost, we just accept the default
        if (!isPromptableRequest(msg)) {
            await this.notify(msg);
            return msg.defaultResponse;
        }
        const response = await this.withCorkedLogging(async () => {
            // prepare prompt data
            // @todo this format is not defined anywhere, probably should be
            const data = msg.data ?? {};
            const motivation = data.motivation ?? 'User input is needed';
            const concurrency = data.concurrency ?? 0;
            // only talk to user if STDIN is a terminal (otherwise, fail)
            if (!this.isTTY) {
                throw new api_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
            }
            // only talk to user if concurrency is 1 (otherwise, fail)
            if (concurrency > 1) {
                throw new api_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
            }
            // Special approval prompt
            // Determine if the message needs approval. If it does, continue (it is a basic confirmation prompt)
            // If it does not, return success (true). We only check messages with codes that we are aware
            // are requires approval codes.
            if (this.skipApprovalStep(msg)) {
                return true;
            }
            // Basic confirmation prompt
            // We treat all requests with a boolean response as confirmation prompts
            if (isConfirmationPrompt(msg)) {
                const confirmed = await promptly.confirm(`${chalk.cyan(msg.message)} (y/n)`);
                if (!confirmed) {
                    throw new api_1.ToolkitError('Aborted by user');
                }
                return confirmed;
            }
            // Asking for a specific value
            const prompt = extractPromptInfo(msg);
            const answer = await promptly.prompt(`${chalk.cyan(msg.message)} (${prompt.default})`, {
                default: prompt.default,
            });
            return prompt.convertAnswer(answer);
        });
        // We need to cast this because it is impossible to narrow the generic type
        // isPromptableRequest ensures that the response type is one we can prompt for
        // the remaining code ensure we are indeed returning the correct type
        return response;
    }
    /**
     * Formats a message for console output with optional color support
     */
    formatMessage(msg) {
        // apply provided style or a default style if we're in TTY mode
        let message_text = this.isTTY
            ? styleMap[msg.level](msg.message)
            : msg.message;
        // prepend timestamp if IoMessageLevel is DEBUG or TRACE. Postpend a newline.
        return ((msg.level === 'debug' || msg.level === 'trace')
            ? `[${this.formatTime(msg.time)}] ${message_text}`
            : message_text) + '\n';
    }
    /**
     * Formats date to HH:MM:SS
     */
    formatTime(d) {
        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    /**
     * Get an instance of the ActivityPrinter
     */
    makeActivityPrinter() {
        const props = {
            stream: this.selectStreamFromLevel('info'),
        };
        switch (this.stackProgress) {
            case deploy_1.StackActivityProgress.EVENTS:
                return new activity_printer_1.HistoryActivityPrinter(props);
            case deploy_1.StackActivityProgress.BAR:
                return new activity_printer_1.CurrentActivityPrinter(props);
        }
    }
}
exports.CliIoHost = CliIoHost;
/**
 * This IoHost implementation considers a request promptable, if:
 * - it's a yes/no confirmation
 * - asking for a string or number value
 */
function isPromptableRequest(msg) {
    return isConfirmationPrompt(msg)
        || typeof msg.defaultResponse === 'string'
        || typeof msg.defaultResponse === 'number';
}
/**
 * Check if the request is a confirmation prompt
 * We treat all requests with a boolean response as confirmation prompts
 */
function isConfirmationPrompt(msg) {
    return typeof msg.defaultResponse === 'boolean';
}
/**
 * Helper to extract information for promptly from the request
 */
function extractPromptInfo(msg) {
    const isNumber = (typeof msg.defaultResponse === 'number');
    return {
        default: util.format(msg.defaultResponse),
        convertAnswer: isNumber ? (v) => Number(v) : (v) => String(v),
    };
}
const styleMap = {
    error: chalk.red,
    warn: chalk.yellow,
    result: chalk.white,
    info: chalk.white,
    debug: chalk.gray,
    trace: chalk.gray,
};
/**
 * Returns true if the current process is running in a CI environment
 * @returns true if the current process is running in a CI environment
 */
function isCI() {
    return process.env.CI !== undefined && process.env.CI !== 'false' && process.env.CI !== '0';
}
function targetStreamObject(x) {
    switch (x) {
        case 'stderr':
            return process.stderr;
        case 'stdout':
            return process.stdout;
        case 'drop':
            return undefined;
    }
}
function isNoticesMessage(msg) {
    return private_1.IO.CDK_TOOLKIT_I0100.is(msg) || private_1.IO.CDK_TOOLKIT_W0101.is(msg) || private_1.IO.CDK_TOOLKIT_E0101.is(msg) || private_1.IO.CDK_TOOLKIT_I0101.is(msg);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWlvLWhvc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktaW8taG9zdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUE4ZUEsb0JBRUM7QUFoZkQsa0NBQWtDO0FBQ2xDLDBFQUFpRTtBQUNqRSwrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLDBFQUFnRjtBQUdoRix5RkFBMkk7QUFDM0ksa0RBQThEO0FBQzlELDBEQUFxRjtBQXNFckY7O0dBRUc7QUFDSCxNQUFhLFNBQVM7SUFDcEI7O09BRUc7SUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQXdCLEVBQUUsRUFBRSxRQUFRLEdBQUcsS0FBSztRQUMxRCxJQUFJLFFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyQyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQXNERCxZQUFvQixRQUF3QixFQUFFO1FBbEI5Qzs7Ozs7V0FLRztRQUNJLHVCQUFrQixHQUFpQixRQUFRLENBQUM7UUFHM0MsY0FBUyxHQUEwQiw4QkFBcUIsQ0FBQyxHQUFHLENBQUM7UUFLckUsaUJBQWlCO1FBQ1Qsa0JBQWEsR0FBRyxDQUFDLENBQUM7UUFDVCx3QkFBbUIsR0FBeUIsRUFBRSxDQUFDO1FBRzlELElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDLGFBQWEsSUFBSSxNQUFNLENBQUM7UUFDbkQsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQztRQUMxRCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksSUFBSSxJQUFJ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QVMsa0JBQWtCLENBQUMsQ0FBZTtJQUN6QyxRQUFRLENBQUMsRUFBRSxDQUFDO1FBQ1YsS0FBSyxRQUFRO1lBQ1gsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ3hCLEtBQUssUUFBUTtZQUNYLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUN4QixLQUFLLE1BQU07WUFDVCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsZ0JBQWdCLENBQUMsR0FBdUI7SUFDL0MsT0FBTyxZQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksWUFBRSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxZQUFFLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3RJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgeyBSZXF1aXJlQXBwcm92YWwgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpJztcbmltcG9ydCB0eXBlIHsgSUlvSG9zdCwgSW9NZXNzYWdlLCBJb01lc3NhZ2VDb2RlLCBJb01lc3NhZ2VMZXZlbCwgSW9SZXF1ZXN0LCBUb29sa2l0QWN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpJztcbmltcG9ydCB0eXBlIHsgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBhc0lvSGVscGVyLCBJTywgSW9EZWZhdWx0TWVzc2FnZXMsIGlzTWVzc2FnZVJlbGV2YW50Rm9yTGV2ZWwgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuLi8uLi9jb21tYW5kcy9kZXBsb3knO1xuaW1wb3J0IHsgQ3VycmVudEFjdGl2aXR5UHJpbnRlciwgSGlzdG9yeUFjdGl2aXR5UHJpbnRlciB9IGZyb20gJy4uL2FjdGl2aXR5LXByaW50ZXInO1xuaW1wb3J0IHR5cGUgeyBBY3Rpdml0eVByaW50ZXJQcm9wcywgSUFjdGl2aXR5UHJpbnRlciB9IGZyb20gJy4uL2FjdGl2aXR5LXByaW50ZXInO1xuXG5leHBvcnQgdHlwZSB7IElJb0hvc3QsIElvTWVzc2FnZSwgSW9NZXNzYWdlQ29kZSwgSW9NZXNzYWdlTGV2ZWwsIElvUmVxdWVzdCB9O1xuXG50eXBlIENsaUFjdGlvbiA9XG58IFRvb2xraXRBY3Rpb25cbnwgJ2NvbnRleHQnXG58ICdkb2NzJ1xufCAnbm90aWNlcydcbnwgJ3ZlcnNpb24nXG58ICdub25lJztcblxuZXhwb3J0IGludGVyZmFjZSBDbGlJb0hvc3RQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBUb29sa2l0IGFjdGlvbiB0aGUgaG9zdHMgc3RhcnRzIHdpdGguXG4gICAqXG4gICAqIEBkZWZhdWx0ICdub25lJ1xuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudEFjdGlvbj86IFRvb2xraXRBY3Rpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHZlcmJvc2l0eSBvZiB0aGUgb3V0cHV0LlxuICAgKlxuICAgKiBUaGUgQ2xpSW9Ib3N0IHdpbGwgc3RpbGwgcmVjZWl2ZSBhbGwgbWVzc2FnZXMgYW5kIHJlcXVlc3RzLFxuICAgKiBidXQgb25seSB0aGUgbWVzc2FnZXMgaW5jbHVkZWQgaW4gdGhpcyBsZXZlbCB3aWxsIGJlIHByaW50ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0ICdpbmZvJ1xuICAgKi9cbiAgcmVhZG9ubHkgbG9nTGV2ZWw/OiBJb01lc3NhZ2VMZXZlbDtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgVFRZIGRldGVjdGlvbi5cbiAgICpcbiAgICogV2hlbiBUVFkgaXMgZGlzYWJsZWQsIHRoZSBDTEkgd2lsbCBoYXZlIG5vIGludGVyYWN0aW9ucyBvciBjb2xvci5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZXRlcm1pbmVkIGZyb20gdGhlIGN1cnJlbnQgcHJvY2Vzc1xuICAgKi9cbiAgcmVhZG9ubHkgaXNUVFk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLlxuICAgKlxuICAgKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICogU2V0IHRvIGZhbHNlIGluIHRoZSBDbGlJb0hvc3QgY29uc3RydWN0b3IgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBpZiB0aGUgQ0xJIENJIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRldGVybWluZWQgZnJvbSB0aGUgZW52aXJvbm1lbnQsIHNwZWNpZmljYWxseSBiYXNlZCBvbiBgcHJvY2Vzcy5lbnYuQ0lgXG4gICAqL1xuICByZWFkb25seSBpc0NJPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW4gd2hhdCBzY2VuYXJpb3Mgc2hvdWxkIHRoZSBDbGlJb0hvc3QgYXNrIGZvciBhcHByb3ZhbFxuICAgKlxuICAgKiBAZGVmYXVsdCBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklOR1xuICAgKi9cbiAgcmVhZG9ubHkgcmVxdWlyZURlcGxveUFwcHJvdmFsPzogUmVxdWlyZUFwcHJvdmFsO1xuXG4gIC8qXG4gICAqIFRoZSBpbml0aWFsIFRvb2xraXQgYWN0aW9uIHRoZSBob3N0cyBzdGFydHMgd2l0aC5cbiAgICpcbiAgICogQGRlZmF1bHQgU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJBUlxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tQcm9ncmVzcz86IFN0YWNrQWN0aXZpdHlQcm9ncmVzcztcbn1cblxuLyoqXG4gKiBBIHR5cGUgZm9yIGNvbmZpZ3VyaW5nIGEgdGFyZ2V0IHN0cmVhbVxuICovXG5leHBvcnQgdHlwZSBUYXJnZXRTdHJlYW0gPSAnc3Rkb3V0JyB8ICdzdGRlcnInIHwgJ2Ryb3AnO1xuXG4vKipcbiAqIEEgc2ltcGxlIElPIGhvc3QgZm9yIHRoZSBDTEkgdGhhdCB3cml0ZXMgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGlJb0hvc3QgaW1wbGVtZW50cyBJSW9Ib3N0IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKHByb3BzOiBDbGlJb0hvc3RQcm9wcyA9IHt9LCBmb3JjZU5ldyA9IGZhbHNlKTogQ2xpSW9Ib3N0IHtcbiAgICBpZiAoZm9yY2VOZXcgfHwgIUNsaUlvSG9zdC5faW5zdGFuY2UpIHtcbiAgICAgIENsaUlvSG9zdC5faW5zdGFuY2UgPSBuZXcgQ2xpSW9Ib3N0KHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIENsaUlvSG9zdC5faW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogU2luZ2xldG9uIGluc3RhbmNlIG9mIHRoZSBDbGlJb0hvc3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogQ2xpSW9Ib3N0IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDTEkuXG4gICAqL1xuICBwdWJsaWMgY3VycmVudEFjdGlvbjogQ2xpQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDbGlJb0hvc3QgaXMgcnVubmluZyBpbiBDSSBtb2RlLlxuICAgKlxuICAgKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICovXG4gIHB1YmxpYyBpc0NJOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBob3N0IGNhbiB1c2UgaW50ZXJhY3Rpb25zIGFuZCBtZXNzYWdlIHN0eWxpbmcuXG4gICAqL1xuICBwdWJsaWMgaXNUVFk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVzaG9sZC5cbiAgICpcbiAgICogTWVzc2FnZXMgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgaWdub3JlZC5cbiAgICovXG4gIHB1YmxpYyBsb2dMZXZlbDogSW9NZXNzYWdlTGV2ZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBjb25kaXRpb25zIGZvciByZXF1aXJpbmcgYXBwcm92YWwgaW4gdGhpcyBDbGlJb0hvc3QuXG4gICAqL1xuICBwdWJsaWMgcmVxdWlyZURlcGxveUFwcHJvdmFsOiBSZXF1aXJlQXBwcm92YWw7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgdGFyZ2V0IHN0cmVhbSBmb3Igbm90aWNlc1xuICAgKlxuICAgKiAoTm90IGEgc2V0dGVyIGJlY2F1c2UgdGhlcmUncyBubyBuZWVkIGZvciBhZGRpdGlvbmFsIGxvZ2ljIHdoZW4gdGhpcyB2YWx1ZVxuICAgKiBpcyBjaGFuZ2VkIHlldClcbiAgICovXG4gIHB1YmxpYyBub3RpY2VzRGVzdGluYXRpb246IFRhcmdldFN0cmVhbSA9ICdzdGRlcnInO1xuXG4gIHByaXZhdGUgX2ludGVybmFsSW9Ib3N0PzogSUlvSG9zdDtcbiAgcHJpdmF0ZSBfcHJvZ3Jlc3M6IFN0YWNrQWN0aXZpdHlQcm9ncmVzcyA9IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI7XG5cbiAgLy8gU3RhY2sgQWN0aXZpdHkgUHJpbnRlclxuICBwcml2YXRlIGFjdGl2aXR5UHJpbnRlcj86IElBY3Rpdml0eVByaW50ZXI7XG5cbiAgLy8gQ29ya2VkIExvZ2dpbmdcbiAgcHJpdmF0ZSBjb3JrZWRDb3VudGVyID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb3JrZWRMb2dnaW5nQnVmZmVyOiBJb01lc3NhZ2U8dW5rbm93bj5bXSA9IFtdO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IocHJvcHM6IENsaUlvSG9zdFByb3BzID0ge30pIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSBwcm9wcy5jdXJyZW50QWN0aW9uID8/ICdub25lJztcbiAgICB0aGlzLmlzVFRZID0gcHJvcHMuaXNUVFkgPz8gcHJvY2Vzcy5zdGRvdXQuaXNUVFkgPz8gZmFsc2U7XG4gICAgdGhpcy5sb2dMZXZlbCA9IHByb3BzLmxvZ0xldmVsID8/ICdpbmZvJztcbiAgICB0aGlzLmlzQ0kgPSBwcm9wcy5pc0NJID8/IGlzQ0koKTtcbiAgICB0aGlzLnJlcXVpcmVEZXBsb3lBcHByb3ZhbCA9IHByb3BzLnJlcXVpcmVEZXBsb3lBcHByb3ZhbCA/PyBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklORztcblxuICAgIHRoaXMuc3RhY2tQcm9ncmVzcyA9IHByb3BzLnN0YWNrUHJvZ3Jlc3MgPz8gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJBUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlcklvSG9zdChpb0hvc3Q6IElJb0hvc3QpIHtcbiAgICBpZiAoaW9Ib3N0ICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbElvSG9zdCA9IGlvSG9zdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGFja1Byb2dyZXNzIHByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YWNrUHJvZ3Jlc3ModHlwZTogU3RhY2tBY3Rpdml0eVByb2dyZXNzKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YWNrUHJvZ3Jlc3MgdmFsdWUuXG4gICAqXG4gICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IG90aGVyIHN0YXRlIG9mIHRoZSBpb0hvc3QsXG4gICAqIGxpa2UgaWYgaXNUVFkgYW5kIGlzQ0kuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrUHJvZ3Jlc3MoKTogU3RhY2tBY3Rpdml0eVByb2dyZXNzIHtcbiAgICAvLyBXZSBjYW4gYWx3YXlzIHVzZSBFVkVOVFNcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPT09IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBpZiBhIGRlYnVnIG1lc3NhZ2UgKGFuZCB0aHVzIGFueSBtb3JlIHZlcmJvc2UgbWVzc2FnZXMpIGFyZSByZWxldmFudCB0byB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIHdlIGhhdmUgdmVyYm9zZSBsb2dnaW5nXG4gICAgY29uc3QgdmVyYm9zZUxvZ2dpbmcgPSBpc01lc3NhZ2VSZWxldmFudEZvckxldmVsKHsgbGV2ZWw6ICdkZWJ1ZycgfSwgdGhpcy5sb2dMZXZlbCk7XG4gICAgaWYgKHZlcmJvc2VMb2dnaW5nKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBXaW5kb3dzIHdlIGNhbm5vdCB1c2UgZmFuY3kgb3V0cHV0XG4gICAgY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIENJIHN5c3RlbXMgKHN1Y2ggYXMgQ2lyY2xlQ0kpIG91dHB1dCBzdGlsbCByZXBvcnRzIGFzIGEgVFRZIHNvIHdlIGFsc29cbiAgICAvLyBuZWVkIGFuIGluZGl2aWR1YWwgY2hlY2sgZm9yIHdoZXRoZXIgd2UncmUgcnVubmluZyBvbiBDSS5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZGlzY3Vzcy5jaXJjbGVjaS5jb20vdC9jaXJjbGVjaS10ZXJtaW5hbC1pcy1hLXR0eS1idXQtdGVybS1pcy1ub3Qtc2V0Lzk5NjVcbiAgICBjb25zdCBmYW5jeU91dHB1dEF2YWlsYWJsZSA9IHRoaXMuaXNUVFkgJiYgIXRoaXMuaXNDSTtcbiAgICBpZiAoIWZhbmN5T3V0cHV0QXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHVzZXIgcHJlZmVyZW5jZVxuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIG5ldyBJb0RlZmF1bHRNZXNzYWdlcyh0aGlzLmFzSW9IZWxwZXIoKSk7XG4gIH1cblxuICBwdWJsaWMgYXNJb0hlbHBlcigpOiBJb0hlbHBlciB7XG4gICAgcmV0dXJuIGFzSW9IZWxwZXIodGhpcywgdGhpcy5jdXJyZW50QWN0aW9uIGFzIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBibG9jayBvZiBjb2RlIHdpdGggY29ya2VkIGxvZ2dpbmcuIEFsbCBsb2cgbWVzc2FnZXMgZHVyaW5nIGV4ZWN1dGlvblxuICAgKiBhcmUgYnVmZmVyZWQgYW5kIG9ubHkgd3JpdHRlbiB3aGVuIGFsbCBuZXN0ZWQgY29yayBibG9ja3MgY29tcGxldGUgKHdoZW4gQ09SS19DT1VOVEVSIHJlYWNoZXMgMCkuXG4gICAqIFRoZSBjb3JraW5nIGlzIGJvdW5kIHRvIHRoZSBzcGVjaWZpYyBpbnN0YW5jZSBvZiB0aGUgQ2xpSW9Ib3N0LlxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2sgLSBBc3luYyBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGggY29ya2VkIGxvZ2dpbmdcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJsb2NrJ3MgcmV0dXJuIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgd2l0aENvcmtlZExvZ2dpbmc8VD4oYmxvY2s6ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICB0aGlzLmNvcmtlZENvdW50ZXIrKztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGJsb2NrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuY29ya2VkQ291bnRlci0tO1xuICAgICAgaWYgKHRoaXMuY29ya2VkQ291bnRlciA9PT0gMCkge1xuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggYnVmZmVyZWQgbWVzc2FnZSB0aHJvdWdoIG5vdGlmeVxuICAgICAgICBmb3IgKGNvbnN0IGlvTWVzc2FnZSBvZiB0aGlzLmNvcmtlZExvZ2dpbmdCdWZmZXIpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeShpb01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYnVmZmVyZWQgbWVzc2FnZXMgaW4tcGxhY2VcbiAgICAgICAgdGhpcy5jb3JrZWRMb2dnaW5nQnVmZmVyLnNwbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlLlxuICAgKiBUaGUgY2FsbGVyIHdhaXRzIHVudGlsIHRoZSBub3RpZmljYXRpb24gY29tcGxldGVzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIG5vdGlmeShtc2c6IElvTWVzc2FnZTx1bmtub3duPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLl9pbnRlcm5hbElvSG9zdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsSW9Ib3N0Lm5vdGlmeShtc2cpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3RhY2tBY3Rpdml0eShtc2cpKSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZpdHlQcmludGVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlQcmludGVyID0gdGhpcy5tYWtlQWN0aXZpdHlQcmludGVyKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmFjdGl2aXR5UHJpbnRlci5ub3RpZnkobXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzTWVzc2FnZVJlbGV2YW50Rm9yTGV2ZWwobXNnLCB0aGlzLmxvZ0xldmVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvcmtlZENvdW50ZXIgPiAwKSB7XG4gICAgICB0aGlzLmNvcmtlZExvZ2dpbmdCdWZmZXIucHVzaChtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuZm9ybWF0TWVzc2FnZShtc2cpO1xuICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc2VsZWN0U3RyZWFtKG1zZyk7XG4gICAgc3RyZWFtPy53cml0ZShvdXRwdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzdGFjayBhY3Rpdml0eSBtZXNzYWdlcyBzbyB0aGV5IGNhbiBiZSBzZW5kIHRvIHRoZSBwcmludGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1N0YWNrQWN0aXZpdHkobXNnOiBJb01lc3NhZ2U8dW5rbm93bj4pIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ0NES19UT09MS0lUX0k1NTAxJyxcbiAgICAgICdDREtfVE9PTEtJVF9JNTUwMicsXG4gICAgICAnQ0RLX1RPT0xLSVRfSTU1MDMnLFxuICAgIF0uaW5jbHVkZXMobXNnLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzcGVjaWFsIG1lc3NhZ2VzIGVuY29kZSBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGV5IHJlcXVpcmUgYXBwcm92YWxcbiAgICovXG4gIHByaXZhdGUgc2tpcEFwcHJvdmFsU3RlcChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBib29sZWFuIHtcbiAgICBjb25zdCBhcHByb3ZhbFRvb2xraXRDb2RlcyA9IFsnQ0RLX1RPT0xLSVRfSTUwNjAnXTtcbiAgICBpZiAoIWFwcHJvdmFsVG9vbGtpdENvZGVzLmluY2x1ZGVzKG1zZy5jb2RlKSkge1xuICAgICAgZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnJlcXVpcmVEZXBsb3lBcHByb3ZhbCkge1xuICAgICAgLy8gTmV2ZXIgcmVxdWlyZSBhcHByb3ZhbFxuICAgICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuTkVWRVI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgLy8gQWx3YXlzIHJlcXVpcmUgYXBwcm92YWxcbiAgICAgIGNhc2UgUmVxdWlyZUFwcHJvdmFsLkFOWUNIQU5HRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gUmVxdWlyZSBhcHByb3ZhbCBpZiBjaGFuZ2VzIGluY2x1ZGUgYnJvYWRlbmluZyBwZXJtaXNzaW9uc1xuICAgICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuQlJPQURFTklORzpcbiAgICAgICAgcmV0dXJuIFsnbm9uZScsICdub24tYnJvYWRlbmluZyddLmluY2x1ZGVzKG1zZy5kYXRhPy5wZXJtaXNzaW9uQ2hhbmdlVHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG91dHB1dCBzdHJlYW0sIGJhc2VkIG9uIG1lc3NhZ2UgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIHNlbGVjdFN0cmVhbShtc2c6IElvTWVzc2FnZTxhbnk+KTogTm9kZUpTLldyaXRlU3RyZWFtIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaXNOb3RpY2VzTWVzc2FnZShtc2cpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0U3RyZWFtT2JqZWN0KHRoaXMubm90aWNlc0Rlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZWxlY3RTdHJlYW1Gcm9tTGV2ZWwobXNnLmxldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBvdXRwdXQgc3RyZWFtLCBiYXNlZCBvbiBtZXNzYWdlIGxldmVsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RTdHJlYW1Gcm9tTGV2ZWwobGV2ZWw6IElvTWVzc2FnZUxldmVsKTogTm9kZUpTLldyaXRlU3RyZWFtIHtcbiAgICAvLyBUaGUgc3RyZWFtIHNlbGVjdGlvbiBwb2xpY3kgZm9yIHRoZSBDTEkgaXMgdGhlIGZvbGxvd2luZzpcbiAgICAvL1xuICAgIC8vICAgKDEpIE1lc3NhZ2VzIG9mIGxldmVsIGByZXN1bHRgIGFsd2F5cyBnbyB0byBgc3Rkb3V0YFxuICAgIC8vICAgKDIpIE1lc3NhZ2VzIG9mIGxldmVsIGBlcnJvcmAgYWx3YXlzIGdvIHRvIGBzdGRlcnJgLlxuICAgIC8vICAgKDNhKSBBbGwgcmVtYWluaW5nIG1lc3NhZ2VzIGdvIHRvIGBzdGRlcnJgLlxuICAgIC8vICAgKDNiKSBJZiB3ZSBhcmUgaW4gQ0kgbW9kZSwgYWxsIHJlbWFpbmluZyBtZXNzYWdlcyBnbyB0byBgc3Rkb3V0YC5cbiAgICAvL1xuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyO1xuICAgICAgY2FzZSAncmVzdWx0JzpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDSSA/IHByb2Nlc3Muc3Rkb3V0IDogcHJvY2Vzcy5zdGRlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBob3N0IG9mIGEgbWVzc2FnZSB0aGF0IHJlcXVpcmVzIGEgcmVzcG9uc2UuXG4gICAqXG4gICAqIElmIHRoZSBob3N0IGRvZXMgbm90IHJldHVybiBhIHJlc3BvbnNlIHRoZSBzdWdnZXN0ZWRcbiAgICogZGVmYXVsdCByZXNwb25zZSBmcm9tIHRoZSBpbnB1dCBtZXNzYWdlIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZXF1ZXN0UmVzcG9uc2U8RGF0YVR5cGUsIFJlc3BvbnNlVHlwZT4obXNnOiBJb1JlcXVlc3Q8RGF0YVR5cGUsIFJlc3BvbnNlVHlwZT4pOiBQcm9taXNlPFJlc3BvbnNlVHlwZT4ge1xuICAgIC8vIEZpcnN0IGNhbGwgb3V0IHRvIGEgcmVnaXN0ZXJlZCBpbnN0YW5jZSBpZiB3ZSBoYXZlIG9uZVxuICAgIGlmICh0aGlzLl9pbnRlcm5hbElvSG9zdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsSW9Ib3N0LnJlcXVlc3RSZXNwb25zZShtc2cpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSByZXF1ZXN0IGNhbm5vdCBiZSBwcm9tcHRlZCBmb3IgYnkgdGhlIENsaUlvSG9zdCwgd2UganVzdCBhY2NlcHQgdGhlIGRlZmF1bHRcbiAgICBpZiAoIWlzUHJvbXB0YWJsZVJlcXVlc3QobXNnKSkge1xuICAgICAgYXdhaXQgdGhpcy5ub3RpZnkobXNnKTtcbiAgICAgIHJldHVybiBtc2cuZGVmYXVsdFJlc3BvbnNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53aXRoQ29ya2VkTG9nZ2luZyhhc3luYyAoKTogUHJvbWlzZTxzdHJpbmcgfCBudW1iZXIgfCB0cnVlPiA9PiB7XG4gICAgICAvLyBwcmVwYXJlIHByb21wdCBkYXRhXG4gICAgICAvLyBAdG9kbyB0aGlzIGZvcm1hdCBpcyBub3QgZGVmaW5lZCBhbnl3aGVyZSwgcHJvYmFibHkgc2hvdWxkIGJlXG4gICAgICBjb25zdCBkYXRhOiB7XG4gICAgICAgIG1vdGl2YXRpb24/OiBzdHJpbmc7XG4gICAgICAgIGNvbmN1cnJlbmN5PzogbnVtYmVyO1xuICAgICAgfSA9IG1zZy5kYXRhID8/IHt9O1xuXG4gICAgICBjb25zdCBtb3RpdmF0aW9uID0gZGF0YS5tb3RpdmF0aW9uID8/ICdVc2VyIGlucHV0IGlzIG5lZWRlZCc7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9IGRhdGEuY29uY3VycmVuY3kgPz8gMDtcblxuICAgICAgLy8gb25seSB0YWxrIHRvIHVzZXIgaWYgU1RESU4gaXMgYSB0ZXJtaW5hbCAob3RoZXJ3aXNlLCBmYWlsKVxuICAgICAgaWYgKCF0aGlzLmlzVFRZKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYCR7bW90aXZhdGlvbn0sIGJ1dCB0ZXJtaW5hbCAoVFRZKSBpcyBub3QgYXR0YWNoZWQgc28gd2UgYXJlIHVuYWJsZSB0byBnZXQgYSBjb25maXJtYXRpb24gZnJvbSB0aGUgdXNlcmApO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IHRhbGsgdG8gdXNlciBpZiBjb25jdXJyZW5jeSBpcyAxIChvdGhlcndpc2UsIGZhaWwpXG4gICAgICBpZiAoY29uY3VycmVuY3kgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYCR7bW90aXZhdGlvbn0sIGJ1dCBjb25jdXJyZW5jeSBpcyBncmVhdGVyIHRoYW4gMSBzbyB3ZSBhcmUgdW5hYmxlIHRvIGdldCBhIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSB1c2VyYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNwZWNpYWwgYXBwcm92YWwgcHJvbXB0XG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lc3NhZ2UgbmVlZHMgYXBwcm92YWwuIElmIGl0IGRvZXMsIGNvbnRpbnVlIChpdCBpcyBhIGJhc2ljIGNvbmZpcm1hdGlvbiBwcm9tcHQpXG4gICAgICAvLyBJZiBpdCBkb2VzIG5vdCwgcmV0dXJuIHN1Y2Nlc3MgKHRydWUpLiBXZSBvbmx5IGNoZWNrIG1lc3NhZ2VzIHdpdGggY29kZXMgdGhhdCB3ZSBhcmUgYXdhcmVcbiAgICAgIC8vIGFyZSByZXF1aXJlcyBhcHByb3ZhbCBjb2Rlcy5cbiAgICAgIGlmICh0aGlzLnNraXBBcHByb3ZhbFN0ZXAobXNnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQmFzaWMgY29uZmlybWF0aW9uIHByb21wdFxuICAgICAgLy8gV2UgdHJlYXQgYWxsIHJlcXVlc3RzIHdpdGggYSBib29sZWFuIHJlc3BvbnNlIGFzIGNvbmZpcm1hdGlvbiBwcm9tcHRzXG4gICAgICBpZiAoaXNDb25maXJtYXRpb25Qcm9tcHQobXNnKSkge1xuICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBwcm9tcHRseS5jb25maXJtKGAke2NoYWxrLmN5YW4obXNnLm1lc3NhZ2UpfSAoeS9uKWApO1xuICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maXJtZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEFza2luZyBmb3IgYSBzcGVjaWZpYyB2YWx1ZVxuICAgICAgY29uc3QgcHJvbXB0ID0gZXh0cmFjdFByb21wdEluZm8obXNnKTtcbiAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHByb21wdGx5LnByb21wdChgJHtjaGFsay5jeWFuKG1zZy5tZXNzYWdlKX0gKCR7cHJvbXB0LmRlZmF1bHR9KWAsIHtcbiAgICAgICAgZGVmYXVsdDogcHJvbXB0LmRlZmF1bHQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9tcHQuY29udmVydEFuc3dlcihhbnN3ZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBjYXN0IHRoaXMgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIG5hcnJvdyB0aGUgZ2VuZXJpYyB0eXBlXG4gICAgLy8gaXNQcm9tcHRhYmxlUmVxdWVzdCBlbnN1cmVzIHRoYXQgdGhlIHJlc3BvbnNlIHR5cGUgaXMgb25lIHdlIGNhbiBwcm9tcHQgZm9yXG4gICAgLy8gdGhlIHJlbWFpbmluZyBjb2RlIGVuc3VyZSB3ZSBhcmUgaW5kZWVkIHJldHVybmluZyB0aGUgY29ycmVjdCB0eXBlXG4gICAgcmV0dXJuIHJlc3BvbnNlIGFzIFJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgbWVzc2FnZSBmb3IgY29uc29sZSBvdXRwdXQgd2l0aCBvcHRpb25hbCBjb2xvciBzdXBwb3J0XG4gICAqL1xuICBwcml2YXRlIGZvcm1hdE1lc3NhZ2UobXNnOiBJb01lc3NhZ2U8dW5rbm93bj4pOiBzdHJpbmcge1xuICAgIC8vIGFwcGx5IHByb3ZpZGVkIHN0eWxlIG9yIGEgZGVmYXVsdCBzdHlsZSBpZiB3ZSdyZSBpbiBUVFkgbW9kZVxuICAgIGxldCBtZXNzYWdlX3RleHQgPSB0aGlzLmlzVFRZXG4gICAgICA/IHN0eWxlTWFwW21zZy5sZXZlbF0obXNnLm1lc3NhZ2UpXG4gICAgICA6IG1zZy5tZXNzYWdlO1xuXG4gICAgLy8gcHJlcGVuZCB0aW1lc3RhbXAgaWYgSW9NZXNzYWdlTGV2ZWwgaXMgREVCVUcgb3IgVFJBQ0UuIFBvc3RwZW5kIGEgbmV3bGluZS5cbiAgICByZXR1cm4gKChtc2cubGV2ZWwgPT09ICdkZWJ1ZycgfHwgbXNnLmxldmVsID09PSAndHJhY2UnKVxuICAgICAgPyBgWyR7dGhpcy5mb3JtYXRUaW1lKG1zZy50aW1lKX1dICR7bWVzc2FnZV90ZXh0fWBcbiAgICAgIDogbWVzc2FnZV90ZXh0KSArICdcXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgZGF0ZSB0byBISDpNTTpTU1xuICAgKi9cbiAgcHJpdmF0ZSBmb3JtYXRUaW1lKGQ6IERhdGUpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhZCA9IChuOiBudW1iZXIpOiBzdHJpbmcgPT4gbi50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgcmV0dXJuIGAke3BhZChkLmdldEhvdXJzKCkpfToke3BhZChkLmdldE1pbnV0ZXMoKSl9OiR7cGFkKGQuZ2V0U2Vjb25kcygpKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiB0aGUgQWN0aXZpdHlQcmludGVyXG4gICAqL1xuICBwcml2YXRlIG1ha2VBY3Rpdml0eVByaW50ZXIoKSB7XG4gICAgY29uc3QgcHJvcHM6IEFjdGl2aXR5UHJpbnRlclByb3BzID0ge1xuICAgICAgc3RyZWFtOiB0aGlzLnNlbGVjdFN0cmVhbUZyb21MZXZlbCgnaW5mbycpLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhY2tQcm9ncmVzcykge1xuICAgICAgY2FzZSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTOlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlBY3Rpdml0eVByaW50ZXIocHJvcHMpO1xuICAgICAgY2FzZSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQkFSOlxuICAgICAgICByZXR1cm4gbmV3IEN1cnJlbnRBY3Rpdml0eVByaW50ZXIocHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgSW9Ib3N0IGltcGxlbWVudGF0aW9uIGNvbnNpZGVycyBhIHJlcXVlc3QgcHJvbXB0YWJsZSwgaWY6XG4gKiAtIGl0J3MgYSB5ZXMvbm8gY29uZmlybWF0aW9uXG4gKiAtIGFza2luZyBmb3IgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbXB0YWJsZVJlcXVlc3QobXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KTogbXNnIGlzIElvUmVxdWVzdDxhbnksIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4+IHtcbiAgcmV0dXJuIGlzQ29uZmlybWF0aW9uUHJvbXB0KG1zZylcbiAgICB8fCB0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ3N0cmluZydcbiAgICB8fCB0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaXMgYSBjb25maXJtYXRpb24gcHJvbXB0XG4gKiBXZSB0cmVhdCBhbGwgcmVxdWVzdHMgd2l0aCBhIGJvb2xlYW4gcmVzcG9uc2UgYXMgY29uZmlybWF0aW9uIHByb21wdHNcbiAqL1xuZnVuY3Rpb24gaXNDb25maXJtYXRpb25Qcm9tcHQobXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KTogbXNnIGlzIElvUmVxdWVzdDxhbnksIGJvb2xlYW4+IHtcbiAgcmV0dXJuIHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZm9yIHByb21wdGx5IGZyb20gdGhlIHJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb21wdEluZm8obXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KToge1xuICBkZWZhdWx0OiBzdHJpbmc7XG4gIGNvbnZlcnRBbnN3ZXI6IChpbnB1dDogc3RyaW5nKSA9PiBzdHJpbmcgfCBudW1iZXI7XG59IHtcbiAgY29uc3QgaXNOdW1iZXIgPSAodHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdudW1iZXInKTtcbiAgcmV0dXJuIHtcbiAgICBkZWZhdWx0OiB1dGlsLmZvcm1hdChtc2cuZGVmYXVsdFJlc3BvbnNlKSxcbiAgICBjb252ZXJ0QW5zd2VyOiBpc051bWJlciA/ICh2KSA9PiBOdW1iZXIodikgOiAodikgPT4gU3RyaW5nKHYpLFxuICB9O1xufVxuXG5jb25zdCBzdHlsZU1hcDogUmVjb3JkPElvTWVzc2FnZUxldmVsLCAoc3RyOiBzdHJpbmcpID0+IHN0cmluZz4gPSB7XG4gIGVycm9yOiBjaGFsay5yZWQsXG4gIHdhcm46IGNoYWxrLnllbGxvdyxcbiAgcmVzdWx0OiBjaGFsay53aGl0ZSxcbiAgaW5mbzogY2hhbGsud2hpdGUsXG4gIGRlYnVnOiBjaGFsay5ncmF5LFxuICB0cmFjZTogY2hhbGsuZ3JheSxcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHByb2Nlc3MgaXMgcnVubmluZyBpbiBhIENJIGVudmlyb25tZW50XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHByb2Nlc3MgaXMgcnVubmluZyBpbiBhIENJIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NJKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQ0kgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5DSSAhPT0gJ2ZhbHNlJyAmJiBwcm9jZXNzLmVudi5DSSAhPT0gJzAnO1xufVxuXG5mdW5jdGlvbiB0YXJnZXRTdHJlYW1PYmplY3QoeDogVGFyZ2V0U3RyZWFtKTogTm9kZUpTLldyaXRlU3RyZWFtIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnc3RkZXJyJzpcbiAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGVycjtcbiAgICBjYXNlICdzdGRvdXQnOlxuICAgICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0O1xuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc05vdGljZXNNZXNzYWdlKG1zZzogSW9NZXNzYWdlPHVua25vd24+KSB7XG4gIHJldHVybiBJTy5DREtfVE9PTEtJVF9JMDEwMC5pcyhtc2cpIHx8IElPLkNES19UT09MS0lUX1cwMTAxLmlzKG1zZykgfHwgSU8uQ0RLX1RPT0xLSVRfRTAxMDEuaXMobXNnKSB8fCBJTy5DREtfVE9PTEtJVF9JMDEwMS5pcyhtc2cpO1xufVxuIl19