"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setSdkTracing = setSdkTracing;
exports.callTrace = callTrace;
exports.traceMemberMethods = traceMemberMethods;
let ENABLED = false;
let INDENT = 0;
function setSdkTracing(enabled) {
    ENABLED = enabled;
}
/**
 * Method decorator to trace a single static or member method, any time it's called
 */
function callTrace(fn, className, logger) {
    if (!ENABLED || !logger) {
        return;
    }
    logger.info(`[trace] ${' '.repeat(INDENT)}${className || '(anonymous)'}#${fn}()`);
}
/**
 * Method decorator to trace a single member method any time it's called
 */
function traceCall(receiver, _propertyKey, descriptor, parentClassName) {
    const fn = descriptor.value;
    const className = typeof receiver === 'function' ? receiver.name : parentClassName;
    descriptor.value = function (...args) {
        const logger = this.logger;
        if (!ENABLED || typeof logger?.info !== 'function') {
            return fn.apply(this, args);
        }
        logger.info.apply(logger, [`[trace] ${' '.repeat(INDENT)}${className || this.constructor.name || '(anonymous)'}#${fn.name}()`]);
        INDENT += 2;
        const ret = fn.apply(this, args);
        if (ret instanceof Promise) {
            return ret.finally(() => {
                INDENT -= 2;
            });
        }
        else {
            INDENT -= 2;
            return ret;
        }
    };
    return descriptor;
}
/**
 * Class decorator, enable tracing for all member methods on this class
 * @deprecated this doesn't work well with localized logging instances, don't use
 */
function traceMemberMethods(constructor) {
    // Instance members
    for (const [name, descriptor] of Object.entries(Object.getOwnPropertyDescriptors(constructor.prototype))) {
        if (typeof descriptor.value !== 'function') {
            continue;
        }
        const newDescriptor = traceCall(constructor.prototype, name, descriptor, constructor.name) ?? descriptor;
        Object.defineProperty(constructor.prototype, name, newDescriptor);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInRyYWNpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFLQSxzQ0FFQztBQUtELDhCQU1DO0FBbUNELGdEQVNDO0FBNURELElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNwQixJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFFZixTQUFnQixhQUFhLENBQUMsT0FBZ0I7SUFDNUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUNwQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsRUFBVSxFQUFFLFNBQWtCLEVBQUUsTUFBZTtJQUN2RSxJQUFJLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDeEIsT0FBTztJQUNULENBQUM7SUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxTQUFTLElBQUksYUFBYSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEYsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxTQUFTLENBQUMsUUFBZ0IsRUFBRSxZQUFvQixFQUFFLFVBQThCLEVBQUUsZUFBd0I7SUFDakgsTUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQztJQUM1QixNQUFNLFNBQVMsR0FBRyxPQUFPLFFBQVEsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUVuRixVQUFVLENBQUMsS0FBSyxHQUFHLFVBQVUsR0FBRyxJQUFXO1FBQ3pDLE1BQU0sTUFBTSxHQUFJLElBQVksQ0FBQyxNQUFNLENBQUM7UUFDcEMsSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLE1BQU0sRUFBRSxJQUFJLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDbkQsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QixDQUFDO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsV0FBVyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLFNBQVMsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxhQUFhLElBQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNoSSxNQUFNLElBQUksQ0FBQyxDQUFDO1FBRVosTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDakMsSUFBSSxHQUFHLFlBQVksT0FBTyxFQUFFLENBQUM7WUFDM0IsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtnQkFDdEIsTUFBTSxJQUFJLENBQUMsQ0FBQztZQUNkLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLElBQUksQ0FBQyxDQUFDO1lBQ1osT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDO0lBQ0gsQ0FBQyxDQUFDO0lBQ0YsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLFdBQXFCO0lBQ3RELG1CQUFtQjtJQUNuQixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMseUJBQXlCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN6RyxJQUFJLE9BQU8sVUFBVSxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUUsQ0FBQztZQUMzQyxTQUFTO1FBQ1gsQ0FBQztRQUNELE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQztRQUN6RyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBMb2dnZXIgfSBmcm9tICdAc21pdGh5L3R5cGVzJztcblxubGV0IEVOQUJMRUQgPSBmYWxzZTtcbmxldCBJTkRFTlQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2RrVHJhY2luZyhlbmFibGVkOiBib29sZWFuKSB7XG4gIEVOQUJMRUQgPSBlbmFibGVkO1xufVxuXG4vKipcbiAqIE1ldGhvZCBkZWNvcmF0b3IgdG8gdHJhY2UgYSBzaW5nbGUgc3RhdGljIG9yIG1lbWJlciBtZXRob2QsIGFueSB0aW1lIGl0J3MgY2FsbGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVHJhY2UoZm46IHN0cmluZywgY2xhc3NOYW1lPzogc3RyaW5nLCBsb2dnZXI/OiBMb2dnZXIpIHtcbiAgaWYgKCFFTkFCTEVEIHx8ICFsb2dnZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2dnZXIuaW5mbyhgW3RyYWNlXSAkeycgJy5yZXBlYXQoSU5ERU5UKX0ke2NsYXNzTmFtZSB8fCAnKGFub255bW91cyknfSMke2ZufSgpYCk7XG59XG5cbi8qKlxuICogTWV0aG9kIGRlY29yYXRvciB0byB0cmFjZSBhIHNpbmdsZSBtZW1iZXIgbWV0aG9kIGFueSB0aW1lIGl0J3MgY2FsbGVkXG4gKi9cbmZ1bmN0aW9uIHRyYWNlQ2FsbChyZWNlaXZlcjogb2JqZWN0LCBfcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yLCBwYXJlbnRDbGFzc05hbWU/OiBzdHJpbmcpIHtcbiAgY29uc3QgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICBjb25zdCBjbGFzc05hbWUgPSB0eXBlb2YgcmVjZWl2ZXIgPT09ICdmdW5jdGlvbicgPyByZWNlaXZlci5uYW1lIDogcGFyZW50Q2xhc3NOYW1lO1xuXG4gIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICBjb25zdCBsb2dnZXIgPSAodGhpcyBhcyBhbnkpLmxvZ2dlcjtcbiAgICBpZiAoIUVOQUJMRUQgfHwgdHlwZW9mIGxvZ2dlcj8uaW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvLmFwcGx5KGxvZ2dlciwgW2BbdHJhY2VdICR7JyAnLnJlcGVhdChJTkRFTlQpfSR7Y2xhc3NOYW1lIHx8IHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCAnKGFub255bW91cyknfSMke2ZuLm5hbWV9KClgXSk7XG4gICAgSU5ERU5UICs9IDI7XG5cbiAgICBjb25zdCByZXQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJldC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgSU5ERU5UIC09IDI7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgSU5ERU5UIC09IDI7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbi8qKlxuICogQ2xhc3MgZGVjb3JhdG9yLCBlbmFibGUgdHJhY2luZyBmb3IgYWxsIG1lbWJlciBtZXRob2RzIG9uIHRoaXMgY2xhc3NcbiAqIEBkZXByZWNhdGVkIHRoaXMgZG9lc24ndCB3b3JrIHdlbGwgd2l0aCBsb2NhbGl6ZWQgbG9nZ2luZyBpbnN0YW5jZXMsIGRvbid0IHVzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhY2VNZW1iZXJNZXRob2RzKGNvbnN0cnVjdG9yOiBGdW5jdGlvbikge1xuICAvLyBJbnN0YW5jZSBtZW1iZXJzXG4gIGZvciAoY29uc3QgW25hbWUsIGRlc2NyaXB0b3JdIG9mIE9iamVjdC5lbnRyaWVzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGNvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbmV3RGVzY3JpcHRvciA9IHRyYWNlQ2FsbChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUsIGRlc2NyaXB0b3IsIGNvbnN0cnVjdG9yLm5hbWUpID8/IGRlc2NyaXB0b3I7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgbmFtZSwgbmV3RGVzY3JpcHRvcik7XG4gIH1cbn1cbiJdfQ==