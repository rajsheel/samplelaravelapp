"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = tryHotswapDeployment;
const util_1 = require("util");
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const api_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api");
const payloads_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/payloads");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const util_2 = require("../../util");
const cloudformation_1 = require("../cloudformation");
const appsync_mapping_templates_1 = require("../hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("../hotswap/code-build-projects");
const common_1 = require("../hotswap/common");
const ecs_services_1 = require("../hotswap/ecs-services");
const lambda_functions_1 = require("../hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("../hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("../hotswap/stepfunctions-state-machines");
const plugin_1 = require("../plugin");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/consistent-type-imports
const pLimit = require('p-limit');
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return [(0, common_1.nonHotswappableResource)(change)];
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, ioHelper, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
    const hotswapSpan = await ioHelper.span(private_1.SPAN.HOTSWAP).begin({
        stack: stackArtifact,
        mode: hotswapMode,
    });
    const result = await hotswapDeployment(sdkProvider, hotswapSpan, assetParams, stackArtifact, hotswapMode, hotswapPropertyOverrides);
    await hotswapSpan.end(result);
    if (result?.hotswapped === true) {
        return {
            type: 'did-deploy-stack',
            noOp: result.hotswappableChanges.length === 0,
            stackArn: cloudFormationStack.stackId,
            outputs: cloudFormationStack.outputs,
        };
    }
    return undefined;
}
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * Returns information about the attempted hotswap deployment
 */
async function hotswapDeployment(sdkProvider, ioSpan, assetParams, stack, hotswapMode, hotswapPropertyOverrides) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stack.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, plugin_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, cloudformation_1.loadCurrentTemplateWithNestedStacks)(stack, sdk);
    const evaluateCfnTemplate = new cloudformation_1.EvaluateCloudFormationTemplate({
        stackArtifact: stack,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        sdk,
        nestedStacks: currentTemplate.nestedStacks,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stack.template);
    const { hotswappable, nonHotswappable } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStacks, hotswapPropertyOverrides);
    await logRejectedChanges(ioSpan, nonHotswappable, hotswapMode);
    const hotswappableChanges = hotswappable.map(o => o.change);
    const nonHotswappableChanges = nonHotswappable.map(n => n.change);
    await ioSpan.notify(private_1.IO.CDK_TOOLKIT_I5401.msg('Hotswap plan created', {
        stack,
        mode: hotswapMode,
        hotswappableChanges,
        nonHotswappableChanges,
    }));
    // preserve classic hotswap behavior
    if (hotswapMode === 'fall-back') {
        if (nonHotswappableChanges.length > 0) {
            return {
                stack,
                mode: hotswapMode,
                hotswapped: false,
                hotswappableChanges,
                nonHotswappableChanges,
            };
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswapOperations(sdk, ioSpan, hotswappable);
    return {
        stack,
        mode: hotswapMode,
        hotswapped: true,
        hotswappableChanges,
        nonHotswappableChanges,
    };
}
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            change: {
                reason: payloads_1.NonHotswappableReason.OUTPUT,
                description: 'output was changed',
                subject: {
                    type: 'Output',
                    logicalId,
                    metadata: evaluateCfnTemplate.metadataFor(logicalId),
                },
            },
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk, hotswapPropertyOverrides);
            hotswappableResources.push(...nestedHotswappableResources.hotswappable);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappable);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(logicalId, change, evaluateCfnTemplate);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides));
        }
        else {
            nonHotswappableResources.push((0, common_1.nonHotswappableResource)(hotswappableChangeCandidate));
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        // Constant set of promises per resource
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable
                ? hotswappableResources.push(propertyResult)
                : nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappable: hotswappableResources,
        nonHotswappable: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, (resChange) => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, (resChange) => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
    const nestedStack = nestedStackTemplates[logicalId];
    if (!nestedStack.physicalName) {
        return {
            hotswappable: [],
            nonHotswappable: [
                {
                    hotswappable: false,
                    change: {
                        reason: payloads_1.NonHotswappableReason.NESTED_STACK_CREATION,
                        description: 'newly created nested stacks cannot be hotswapped',
                        subject: {
                            type: 'Resource',
                            logicalId,
                            resourceType: 'AWS::CloudFormation::Stack',
                            metadata: evaluateCfnTemplate.metadataFor(logicalId),
                        },
                    },
                },
            ],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStack.physicalName, nestedStack.generatedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.fullDiff(nestedStackTemplates[logicalId].deployedTemplate, nestedStackTemplates[logicalId].generatedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackTemplates[logicalId].nestedStackTemplates, hotswapPropertyOverrides);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return (oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties));
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(logicalId, change, evaluateCfnTemplate) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            change: {
                reason: payloads_1.NonHotswappableReason.RESOURCE_CREATION,
                description: `resource '${logicalId}' was created by this deployment`,
                subject: {
                    type: 'Resource',
                    logicalId,
                    resourceType: change.newValue.Type,
                    metadata: evaluateCfnTemplate.metadataFor(logicalId),
                },
            },
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            logicalId,
            change: {
                reason: payloads_1.NonHotswappableReason.RESOURCE_DELETION,
                description: `resource '${logicalId}' was destroyed by this deployment`,
                subject: {
                    type: 'Resource',
                    logicalId,
                    resourceType: change.oldValue.Type,
                    metadata: evaluateCfnTemplate.metadataFor(logicalId),
                },
            },
        };
    }
    // a resource has had its type changed
    if (change.newValue.Type !== change.oldValue.Type) {
        return {
            hotswappable: false,
            change: {
                reason: payloads_1.NonHotswappableReason.RESOURCE_TYPE_CHANGED,
                description: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
                subject: {
                    type: 'Resource',
                    logicalId,
                    resourceType: change.newValue.Type,
                    metadata: evaluateCfnTemplate.metadataFor(logicalId),
                },
            },
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
        metadata: evaluateCfnTemplate.metadataFor(logicalId),
    };
}
async function applyAllHotswapOperations(sdk, ioSpan, hotswappableChanges) {
    if (hotswappableChanges.length === 0) {
        return Promise.resolve([]);
    }
    await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(`\n${common_1.ICON} hotswapping resources:`));
    const limit = pLimit(10);
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(hotswappableChanges.map(hotswapOperation => limit(() => {
        return applyHotswapOperation(sdk, ioSpan, hotswapOperation);
    })));
}
async function applyHotswapOperation(sdk, ioSpan, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    const resourceText = (r) => r.description ?? `${r.resourceType} '${r.physicalName ?? r.logicalId}'`;
    await ioSpan.notify(private_1.IO.CDK_TOOLKIT_I5402.msg(hotswapOperation.change.resources.map(r => (0, util_1.format)(`   ${common_1.ICON} %s`, chalk.bold(resourceText(r)))).join('\n'), hotswapOperation.change));
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    try {
        await hotswapOperation.apply(sdk);
    }
    catch (e) {
        if (e.name === 'TimeoutError' || e.name === 'AbortError') {
            const result = JSON.parse((0, util_2.formatErrorMessage)(e));
            const error = new api_1.ToolkitError(formatWaiterErrorResult(result));
            error.name = e.name;
            throw error;
        }
        throw e;
    }
    await ioSpan.notify(private_1.IO.CDK_TOOLKIT_I5403.msg(hotswapOperation.change.resources.map(r => (0, util_1.format)(`   ${common_1.ICON} %s %s`, chalk.bold(resourceText(r)), chalk.green('hotswapped!'))).join('\n'), hotswapOperation.change));
    sdk.removeCustomUserAgent(customUserAgent);
}
function formatWaiterErrorResult(result) {
    const main = [
        `Resource is not in the expected state due to waiter status: ${result.state}`,
        result.reason ? `${result.reason}.` : '',
    ].join('. ');
    if (result.observedResponses != null) {
        const observedResponses = Object
            .entries(result.observedResponses)
            .map(([msg, count]) => `  - ${msg} (${count})`)
            .join('\n');
        return `${main} Observed responses:\n${observedResponses}`;
    }
    return main;
}
async function logRejectedChanges(ioSpan, rejectedChanges, hotswapMode) {
    if (rejectedChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === 'hotswap-only') {
        rejectedChanges = rejectedChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (rejectedChanges.length === 0) {
            return;
        }
    }
    const messages = ['']; // start with empty line
    if (hotswapMode === 'hotswap-only') {
        messages.push((0, util_1.format)('%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback')));
    }
    else {
        messages.push((0, util_1.format)('%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:')));
    }
    for (const { change } of rejectedChanges) {
        messages.push('    ' + nonHotswappableChangeMessage(change));
    }
    messages.push(''); // newline
    await ioSpan.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(messages.join('\n')));
}
/**
 * Formats a NonHotswappableChange
 */
function nonHotswappableChangeMessage(change) {
    const subject = change.subject;
    const reason = change.description ?? change.reason;
    switch (subject.type) {
        case 'Output':
            return (0, util_1.format)('output: %s, reason: %s', chalk.bold(subject.logicalId), chalk.red(reason));
        case 'Resource':
            return nonHotswappableResourceMessage(subject, reason);
    }
}
/**
 * Formats a non-hotswappable resource subject
 */
function nonHotswappableResourceMessage(subject, reason) {
    if (subject.rejectedProperties?.length) {
        return (0, util_1.format)('resource: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(subject.logicalId), chalk.bold(subject.resourceType), chalk.bold(subject.rejectedProperties), chalk.red(reason));
    }
    return (0, util_1.format)('resource: %s, type: %s, reason: %s', chalk.bold(subject.logicalId), chalk.bold(subject.resourceType), chalk.red(reason));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUF1RkEsb0RBbUNDO0FBMUhELCtCQUE4QjtBQUM5Qix5REFBeUQ7QUFHekQsK0JBQStCO0FBRS9CLDBFQUFnRjtBQUVoRiwyRkFBcUc7QUFFckcseUZBQXVGO0FBQ3ZGLHFDQUFnRDtBQUdoRCxzREFBd0c7QUFDeEcsb0ZBQW1GO0FBQ25GLHdFQUFzRjtBQU90Riw4Q0FHMkI7QUFDM0IsMERBQXlFO0FBQ3pFLGtFQUFpRjtBQUNqRiw0RUFHMEM7QUFDMUMsMEZBQTJGO0FBQzNGLHNDQUFpQztBQUVqQyw2RUFBNkU7QUFDN0UsNEdBQTRHO0FBQzVHLE1BQU0sTUFBTSxHQUE2QixPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFXNUQsTUFBTSxrQkFBa0IsR0FBdUM7SUFDN0QsU0FBUztJQUNULHVCQUF1QixFQUFFLHFEQUFrQztJQUMzRCxzQkFBc0IsRUFBRSxxREFBa0M7SUFDMUQsb0JBQW9CLEVBQUUscURBQWtDO0lBRXhELFVBQVU7SUFDVix3QkFBd0IsRUFBRSx1REFBMkI7SUFDckQscUNBQXFDLEVBQUUsdURBQTJCO0lBQ2xFLDZCQUE2QixFQUFFLHVEQUEyQjtJQUMxRCxzQkFBc0IsRUFBRSx1REFBMkI7SUFFbkQsMEJBQTBCLEVBQUUsNkNBQThCO0lBQzFELHlCQUF5QixFQUFFLDBEQUFvQztJQUMvRCxrQ0FBa0MsRUFBRSwrREFBZ0M7SUFDcEUsNkJBQTZCLEVBQUUsOERBQXNDO0lBQ3JFLGtCQUFrQixFQUFFLEtBQUssRUFDdkIsU0FBaUIsRUFDakIsTUFBc0IsRUFDdEIsbUJBQW1ELEVBQ3pCLEVBQUU7UUFDNUIsNEVBQTRFO1FBQzVFLElBQUksTUFBTSxJQUFBLGlFQUF5QyxFQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsRUFBRSxDQUFDO1lBQzVG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LDhCQUE4QixDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMzRCxDQUFDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyw4QkFBOEIsQ0FBQyxPQUF3QixFQUFFLE1BQWM7SUFDOUUsSUFBSSxPQUFPLENBQUMsa0JBQWtCLEVBQUUsTUFBTSxFQUFFLENBQUM7UUFDdkMsT0FBTyxJQUFBLGFBQU0sRUFDWCwwREFBMEQsRUFDMUQsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQzdCLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUNoQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxFQUN0QyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUNsQixDQUFDO0lBQ0osQ0FBQztJQUVELE9BQU8sSUFBQSxhQUFNLEVBQ1gsb0NBQW9DLEVBQ3BDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUM3QixLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFDaEMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FDbEIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBXYWl0ZXJSZXN1bHQgfSBmcm9tICdAc21pdGh5L3V0aWwtd2FpdGVyJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB0eXBlIHsgU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi9kZXBsb3ltZW50LXJlc3VsdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGknO1xuaW1wb3J0IHR5cGUgeyBBZmZlY3RlZFJlc291cmNlLCBIb3Rzd2FwUmVzdWx0LCBSZXNvdXJjZVN1YmplY3QsIFJlc291cmNlQ2hhbmdlLCBOb25Ib3Rzd2FwcGFibGVDaGFuZ2UgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcGF5bG9hZHMnO1xuaW1wb3J0IHsgTm9uSG90c3dhcHBhYmxlUmVhc29uIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3BheWxvYWRzJztcbmltcG9ydCB0eXBlIHsgSU1lc3NhZ2VTcGFuLCBJb0hlbHBlciB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pby9wcml2YXRlJztcbmltcG9ydCB7IElPLCBTUEFOIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuaW1wb3J0IHsgZm9ybWF0RXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNESywgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgdHlwZSB7IENsb3VkRm9ybWF0aW9uU3RhY2ssIE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0gZnJvbSAnLi4vY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MsIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSB9IGZyb20gJy4uL2hvdHN3YXAvYXBwc3luYy1tYXBwaW5nLXRlbXBsYXRlcyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UgfSBmcm9tICcuLi9ob3Rzd2FwL2NvZGUtYnVpbGQtcHJvamVjdHMnO1xuaW1wb3J0IHR5cGUge1xuICBIb3Rzd2FwQ2hhbmdlLFxuICBIb3Rzd2FwT3BlcmF0aW9uLFxuICBSZWplY3RlZENoYW5nZSxcbiAgSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxufSBmcm9tICcuLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQge1xuICBJQ09OLFxuICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZSxcbn0gZnJvbSAnLi4vaG90c3dhcC9jb21tb24nO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlIH0gZnJvbSAnLi4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4uL2hvdHN3YXAvbGFtYmRhLWZ1bmN0aW9ucyc7XG5pbXBvcnQge1xuICBza2lwQ2hhbmdlRm9yUzNEZXBsb3lDdXN0b21SZXNvdXJjZVBvbGljeSxcbiAgaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG59IGZyb20gJy4uL2hvdHN3YXAvczMtYnVja2V0LWRlcGxveW1lbnRzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlIH0gZnJvbSAnLi4vaG90c3dhcC9zdGVwZnVuY3Rpb25zLXN0YXRlLW1hY2hpbmVzJztcbmltcG9ydCB7IE1vZGUgfSBmcm9tICcuLi9wbHVnaW4nO1xuXG4vLyBNdXN0IHVzZSBhIHJlcXVpcmUoKSBvdGhlcndpc2UgZXNidWlsZCBjb21wbGFpbnMgYWJvdXQgY2FsbGluZyBhIG5hbWVzcGFjZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG5jb25zdCBwTGltaXQ6IHR5cGVvZiBpbXBvcnQoJ3AtbGltaXQnKSA9IHJlcXVpcmUoJ3AtbGltaXQnKTtcblxudHlwZSBIb3Rzd2FwRGV0ZWN0b3IgPSAoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IFJlc291cmNlQ2hhbmdlLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKSA9PiBQcm9taXNlPEhvdHN3YXBDaGFuZ2VbXT47XG5cbnR5cGUgSG90c3dhcE1vZGUgPSAnaG90c3dhcC1vbmx5JyB8ICdmYWxsLWJhY2snO1xuXG5jb25zdCBSRVNPVVJDRV9ERVRFQ1RPUlM6IHsgW2tleTogc3RyaW5nXTogSG90c3dhcERldGVjdG9yIH0gPSB7XG4gIC8vIExhbWJkYVxuICAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcbiAgJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcbiAgJ0FXUzo6TGFtYmRhOjpBbGlhcyc6IGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UsXG5cbiAgLy8gQXBwU3luY1xuICAnQVdTOjpBcHBTeW5jOjpSZXNvbHZlcic6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcbiAgJ0FXUzo6QXBwU3luYzo6RnVuY3Rpb25Db25maWd1cmF0aW9uJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpHcmFwaFFMU2NoZW1hJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpBcGlLZXknOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG5cbiAgJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbic6IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSxcbiAgJ0FXUzo6Q29kZUJ1aWxkOjpQcm9qZWN0JzogaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlLFxuICAnQVdTOjpTdGVwRnVuY3Rpb25zOjpTdGF0ZU1hY2hpbmUnOiBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSxcbiAgJ0N1c3RvbTo6Q0RLQnVja2V0RGVwbG95bWVudCc6IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlLFxuICAnQVdTOjpJQU06OlBvbGljeSc6IGFzeW5jIChcbiAgICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgICBjaGFuZ2U6IFJlc291cmNlQ2hhbmdlLFxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgKTogUHJvbWlzZTxIb3Rzd2FwQ2hhbmdlW10+ID0+IHtcbiAgICAvLyBJZiB0aGUgcG9saWN5IGlzIGZvciBhIFMzQnVja2V0RGVwbG95bWVudENoYW5nZSwgd2UgY2FuIGlnbm9yZSB0aGUgY2hhbmdlXG4gICAgaWYgKGF3YWl0IHNraXBDaGFuZ2VGb3JTM0RlcGxveUN1c3RvbVJlc291cmNlUG9saWN5KGxvZ2ljYWxJZCwgY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbbm9uSG90c3dhcHBhYmxlUmVzb3VyY2UoY2hhbmdlKV07XG4gIH0sXG5cbiAgJ0FXUzo6Q0RLOjpNZXRhZGF0YSc6IGFzeW5jICgpID0+IFtdLFxufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaG90c3dhcCBkZXBsb3ltZW50LCBzaG9ydC1jaXJjdWl0aW5nIENsb3VkRm9ybWF0aW9uIGlmIHBvc3NpYmxlLlxuICogSWYgaXQncyBub3QgcG9zc2libGUgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZGVwbG95bWVudFxuICogKGJlY2F1c2UgdGhlIENESyBTdGFjayBjb250YWlucyBjaGFuZ2VzIHRoYXQgY2Fubm90IGJlIGRlcGxveWVkIHdpdGhvdXQgQ2xvdWRGb3JtYXRpb24pLFxuICogcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyeUhvdHN3YXBEZXBsb3ltZW50KFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgYXNzZXRQYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNsb3VkRm9ybWF0aW9uU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssXG4gIHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8U3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IGhvdHN3YXBTcGFuID0gYXdhaXQgaW9IZWxwZXIuc3BhbihTUEFOLkhPVFNXQVApLmJlZ2luKHtcbiAgICBzdGFjazogc3RhY2tBcnRpZmFjdCxcbiAgICBtb2RlOiBob3Rzd2FwTW9kZSxcbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaG90c3dhcERlcGxveW1lbnQoXG4gICAgc2RrUHJvdmlkZXIsXG4gICAgaG90c3dhcFNwYW4sXG4gICAgYXNzZXRQYXJhbXMsXG4gICAgc3RhY2tBcnRpZmFjdCxcbiAgICBob3Rzd2FwTW9kZSxcbiAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICk7XG5cbiAgYXdhaXQgaG90c3dhcFNwYW4uZW5kKHJlc3VsdCk7XG5cbiAgaWYgKHJlc3VsdD8uaG90c3dhcHBlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGlkLWRlcGxveS1zdGFjaycsXG4gICAgICBub09wOiByZXN1bHQuaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDAsXG4gICAgICBzdGFja0FybjogY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja0lkLFxuICAgICAgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsIHNob3J0LWNpcmN1aXRpbmcgQ2xvdWRGb3JtYXRpb24gaWYgcG9zc2libGUuXG4gKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhdHRlbXB0ZWQgaG90c3dhcCBkZXBsb3ltZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhvdHN3YXBEZXBsb3ltZW50KFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gIGlvU3BhbjogSU1lc3NhZ2VTcGFuPGFueT4sXG4gIGFzc2V0UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBob3Rzd2FwTW9kZTogSG90c3dhcE1vZGUsXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKTogUHJvbWlzZTxPbWl0PEhvdHN3YXBSZXN1bHQsICdkdXJhdGlvbic+PiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2suZW52aXJvbm1lbnQpO1xuICAvLyBjcmVhdGUgYSBuZXcgU0RLIHVzaW5nIHRoZSBDTEkgY3JlZGVudGlhbHMsIGJlY2F1c2UgdGhlIGRlZmF1bHQgb25lIHdpbGwgbm90IHdvcmsgZm9yIG5ldy1zdHlsZSBzeW50aGVzaXMgLVxuICAvLyBpdCBhc3N1bWVzIHRoZSBib290c3RyYXAgZGVwbG95IFJvbGUsIHdoaWNoIGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9ucyB0byB1cGRhdGUgTGFtYmRhIGZ1bmN0aW9uc1xuICBjb25zdCBzZGsgPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnYsIE1vZGUuRm9yV3JpdGluZykpLnNkaztcblxuICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyhzdGFjaywgc2RrKTtcblxuICBjb25zdCBldmFsdWF0ZUNmblRlbXBsYXRlID0gbmV3IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSh7XG4gICAgc3RhY2tBcnRpZmFjdDogc3RhY2ssXG4gICAgcGFyYW1ldGVyczogYXNzZXRQYXJhbXMsXG4gICAgYWNjb3VudDogcmVzb2x2ZWRFbnYuYWNjb3VudCxcbiAgICByZWdpb246IHJlc29sdmVkRW52LnJlZ2lvbixcbiAgICBwYXJ0aXRpb246IChhd2FpdCBzZGsuY3VycmVudEFjY291bnQoKSkucGFydGl0aW9uLFxuICAgIHNkayxcbiAgICBuZXN0ZWRTdGFja3M6IGN1cnJlbnRUZW1wbGF0ZS5uZXN0ZWRTdGFja3MsXG4gIH0pO1xuXG4gIGNvbnN0IHN0YWNrQ2hhbmdlcyA9IGNmbl9kaWZmLmZ1bGxEaWZmKGN1cnJlbnRUZW1wbGF0ZS5kZXBsb3llZFJvb3RUZW1wbGF0ZSwgc3RhY2sudGVtcGxhdGUpO1xuICBjb25zdCB7IGhvdHN3YXBwYWJsZSwgbm9uSG90c3dhcHBhYmxlIH0gPSBhd2FpdCBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgICBzdGFja0NoYW5nZXMsXG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZSxcbiAgICBzZGssXG4gICAgY3VycmVudFRlbXBsYXRlLm5lc3RlZFN0YWNrcywgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuICApO1xuXG4gIGF3YWl0IGxvZ1JlamVjdGVkQ2hhbmdlcyhpb1NwYW4sIG5vbkhvdHN3YXBwYWJsZSwgaG90c3dhcE1vZGUpO1xuXG4gIGNvbnN0IGhvdHN3YXBwYWJsZUNoYW5nZXMgPSBob3Rzd2FwcGFibGUubWFwKG8gPT4gby5jaGFuZ2UpO1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzID0gbm9uSG90c3dhcHBhYmxlLm1hcChuID0+IG4uY2hhbmdlKTtcblxuICBhd2FpdCBpb1NwYW4ubm90aWZ5KElPLkNES19UT09MS0lUX0k1NDAxLm1zZygnSG90c3dhcCBwbGFuIGNyZWF0ZWQnLCB7XG4gICAgc3RhY2ssXG4gICAgbW9kZTogaG90c3dhcE1vZGUsXG4gICAgaG90c3dhcHBhYmxlQ2hhbmdlcyxcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLFxuICB9KSk7XG5cbiAgLy8gcHJlc2VydmUgY2xhc3NpYyBob3Rzd2FwIGJlaGF2aW9yXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gJ2ZhbGwtYmFjaycpIHtcbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFjayxcbiAgICAgICAgbW9kZTogaG90c3dhcE1vZGUsXG4gICAgICAgIGhvdHN3YXBwZWQ6IGZhbHNlLFxuICAgICAgICBob3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBhcHBseSB0aGUgc2hvcnQtY2lyY3VpdGFibGUgY2hhbmdlc1xuICBhd2FpdCBhcHBseUFsbEhvdHN3YXBPcGVyYXRpb25zKHNkaywgaW9TcGFuLCBob3Rzd2FwcGFibGUpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhY2ssXG4gICAgbW9kZTogaG90c3dhcE1vZGUsXG4gICAgaG90c3dhcHBlZDogdHJ1ZSxcbiAgICBob3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMsXG4gIH07XG59XG5cbmludGVyZmFjZSBDbGFzc2lmaWVkQ2hhbmdlcyB7XG4gIGhvdHN3YXBwYWJsZTogSG90c3dhcE9wZXJhdGlvbltdO1xuICBub25Ib3Rzd2FwcGFibGU6IFJlamVjdGVkQ2hhbmdlW107XG59XG5cbi8qKlxuICogQ2xhc3NpZmllcyBhbGwgY2hhbmdlcyB0byBhbGwgcmVzb3VyY2VzIGFzIGVpdGhlciBob3Rzd2FwcGFibGUgb3Igbm90LlxuICogTWV0YWRhdGEgY2hhbmdlcyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgbGlzdCBvZiAobm9uKWhvdHN3YXBwYWJsZSByZXNvdXJjZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICBzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZixcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IFNESyxcbiAgbmVzdGVkU3RhY2tOYW1lczogeyBbbmVzdGVkU3RhY2tOYW1lOiBzdHJpbmddOiBOZXN0ZWRTdGFja1RlbXBsYXRlcyB9LFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2xhc3NpZmllZENoYW5nZXM+IHtcbiAgY29uc3QgcmVzb3VyY2VEaWZmZXJlbmNlcyA9IGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXMpO1xuXG4gIGNvbnN0IHByb21pc2VzOiBBcnJheTwoKSA9PiBQcm9taXNlPEhvdHN3YXBDaGFuZ2VbXT4+ID0gW107XG4gIGNvbnN0IGhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxIb3Rzd2FwT3BlcmF0aW9uPigpO1xuICBjb25zdCBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8UmVqZWN0ZWRDaGFuZ2U+KCk7XG4gIGZvciAoY29uc3QgbG9naWNhbElkIG9mIE9iamVjdC5rZXlzKHN0YWNrQ2hhbmdlcy5vdXRwdXRzLmNoYW5nZXMpKSB7XG4gICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIGNoYW5nZToge1xuICAgICAgICByZWFzb246IE5vbkhvdHN3YXBwYWJsZVJlYXNvbi5PVVRQVVQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnb3V0cHV0IHdhcyBjaGFuZ2VkJyxcbiAgICAgICAgc3ViamVjdDoge1xuICAgICAgICAgIHR5cGU6ICdPdXRwdXQnLFxuICAgICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihsb2dpY2FsSWQpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICAvLyBnYXRoZXIgdGhlIHJlc3VsdHMgb2YgdGhlIGRldGVjdG9yIGZ1bmN0aW9uc1xuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIGNoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VEaWZmZXJlbmNlcykpIHtcbiAgICBpZiAoY2hhbmdlLm5ld1ZhbHVlPy5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snICYmIGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgY29uc3QgbmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gYXdhaXQgZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBuZXN0ZWRTdGFja05hbWVzLFxuICAgICAgICBldmFsdWF0ZUNmblRlbXBsYXRlLFxuICAgICAgICBzZGssXG4gICAgICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgICAgICk7XG4gICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMuaG90c3dhcHBhYmxlKTtcbiAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKC4uLm5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcy5ub25Ib3Rzd2FwcGFibGUpO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgPSBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKGxvZ2ljYWxJZCwgY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHJ1biB0aGlzIHRocm91Z2ggdGhlIGRldGVjdG9yIGZ1bmN0aW9ucywgd2UgY2FuIGFscmVhZHkganVkZ2UgdGhpc1xuICAgIGlmICgnaG90c3dhcHBhYmxlJyBpbiBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpIHtcbiAgICAgIGlmICghaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLmhvdHN3YXBwYWJsZSkge1xuICAgICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvdXJjZVR5cGU6IHN0cmluZyA9IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZS5uZXdWYWx1ZS5UeXBlO1xuICAgIGlmIChyZXNvdXJjZVR5cGUgaW4gUkVTT1VSQ0VfREVURUNUT1JTKSB7XG4gICAgICAvLyBydW4gZGV0ZWN0b3IgZnVuY3Rpb25zIGxhemlseSB0byBwcmV2ZW50IHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICAgIHByb21pc2VzLnB1c2goKCkgPT5cbiAgICAgICAgUkVTT1VSQ0VfREVURUNUT1JTW3Jlc291cmNlVHlwZV0obG9naWNhbElkLCBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChub25Ib3Rzd2FwcGFibGVSZXNvdXJjZShob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGFsbCBkZXRlY3RvciByZXN1bHRzXG4gIGNvbnN0IGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzOiBBcnJheTxIb3Rzd2FwQ2hhbmdlW10+ID0gW107XG4gIGZvciAoY29uc3QgZGV0ZWN0b3JSZXN1bHRQcm9taXNlcyBvZiBwcm9taXNlcykge1xuICAgIC8vIENvbnN0YW50IHNldCBvZiBwcm9taXNlcyBwZXIgcmVzb3VyY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICBjb25zdCBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGF3YWl0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMoKSk7XG4gICAgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMucHVzaChob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHJlc291cmNlRGV0ZWN0aW9uUmVzdWx0cyBvZiBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlSZXN1bHQgb2YgcmVzb3VyY2VEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgICBwcm9wZXJ0eVJlc3VsdC5ob3Rzd2FwcGFibGVcbiAgICAgICAgPyBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdClcbiAgICAgICAgOiBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBob3Rzd2FwcGFibGU6IGhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgICBub25Ib3Rzd2FwcGFibGU6IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBjaGFuZ2VzIHRvIHJlc291cmNlcyBpbiB0aGUgZ2l2ZW4gU3RhY2suXG4gKlxuICogQHBhcmFtIHN0YWNrQ2hhbmdlcyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgY2hhbmdlcyB0byBhIGdpdmVuIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZik6IHtcbiAgW2xvZ2ljYWxJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlO1xufSB7XG4gIC8vIHdlIG5lZWQgdG8gY29sbGFwc2UgbG9naWNhbCBJRCByZW5hbWUgY2hhbmdlcyBpbnRvIG9uZSBjaGFuZ2UsXG4gIC8vIGFzIHRoZXkgYXJlIHJlcHJlc2VudGVkIGluIHN0YWNrQ2hhbmdlcyBhcyBhIHBhaXIgb2YgdHdvIGNoYW5nZXM6IG9uZSBhZGRpdGlvbiBhbmQgb25lIHJlbW92YWxcbiAgY29uc3QgYWxsUmVzb3VyY2VDaGFuZ2VzOiB7IFtsb2dJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0gPSBzdGFja0NoYW5nZXMucmVzb3VyY2VzLmNoYW5nZXM7XG4gIGNvbnN0IGFsbFJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIChyZXNDaGFuZ2UpID0+IHJlc0NoYW5nZS5pc1JlbW92YWwpO1xuICBjb25zdCBhbGxOb25SZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCAocmVzQ2hhbmdlKSA9PiAhcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGZvciAoY29uc3QgW2xvZ0lkLCBub25SZW1vdmFsQ2hhbmdlXSBvZiBPYmplY3QuZW50cmllcyhhbGxOb25SZW1vdmFsQ2hhbmdlcykpIHtcbiAgICBpZiAobm9uUmVtb3ZhbENoYW5nZS5pc0FkZGl0aW9uKSB7XG4gICAgICBjb25zdCBhZGRDaGFuZ2UgPSBub25SZW1vdmFsQ2hhbmdlO1xuICAgICAgLy8gc2VhcmNoIGZvciBhbiBpZGVudGljYWwgcmVtb3ZhbCBjaGFuZ2VcbiAgICAgIGNvbnN0IGlkZW50aWNhbFJlbW92YWxDaGFuZ2UgPSBPYmplY3QuZW50cmllcyhhbGxSZW1vdmFsQ2hhbmdlcykuZmluZCgoW18sIHJlbUNoYW5nZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UocmVtQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBpZiB3ZSBmb3VuZCBvbmUsIHRoZW4gdGhpcyBtZWFucyB0aGlzIGlzIGEgcmVuYW1lIGNoYW5nZVxuICAgICAgaWYgKGlkZW50aWNhbFJlbW92YWxDaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgW3JlbW92ZWRMb2dJZCwgcmVtb3ZlZFJlc291cmNlQ2hhbmdlXSA9IGlkZW50aWNhbFJlbW92YWxDaGFuZ2U7XG4gICAgICAgIGFsbE5vblJlbW92YWxDaGFuZ2VzW2xvZ0lkXSA9IG1ha2VSZW5hbWVEaWZmZXJlbmNlKHJlbW92ZWRSZXNvdXJjZUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSByZW1vdmFsIGNoYW5nZSB0aGF0IGZvcm1zIHRoZSByZW5hbWUgcGFpclxuICAgICAgICBkZWxldGUgYWxsUmVtb3ZhbENoYW5nZXNbcmVtb3ZlZExvZ0lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBhcmUgYWxsIG9mIHRoZSByZW1haW5pbmcgcmVtb3ZhbCBjaGFuZ2VzLFxuICAvLyBwbHVzIGFsbCBvZiB0aGUgbm9uLXJlbW92YWwgY2hhbmdlc1xuICAvLyAod2Ugc2F2ZWQgdGhlIHJlbmFtZSBjaGFuZ2VzIGluIHRoYXQgb2JqZWN0IGFscmVhZHkpXG4gIHJldHVybiB7XG4gICAgLi4uYWxsUmVtb3ZhbENoYW5nZXMsXG4gICAgLi4uYWxsTm9uUmVtb3ZhbENoYW5nZXMsXG4gIH07XG59XG5cbi8qKiBGaWx0ZXJzIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxiYWNrIHJldHVybnMgJ3RydWUnIGZvciB0aGUgZ2l2ZW4gdmFsdWUgaW4gdGhlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZpbHRlckRpY3Q8VD4oZGljdDogeyBba2V5OiBzdHJpbmddOiBUIH0sIGZ1bmM6ICh0OiBUKSA9PiBib29sZWFuKTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGljdCkucmVkdWNlKFxuICAgIChhY2MsIFtrZXksIHRdKSA9PiB7XG4gICAgICBpZiAoZnVuYyh0KSkge1xuICAgICAgICBhY2Nba2V5XSA9IHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sXG4gICAge30gYXMgeyBba2V5OiBzdHJpbmddOiBUIH0sXG4gICk7XG59XG5cbi8qKiBGaW5kcyBhbnkgaG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gYWxsIG5lc3RlZCBzdGFja3MuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kTmVzdGVkSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBuZXN0ZWRTdGFja1RlbXBsYXRlczogeyBbbmVzdGVkU3RhY2tOYW1lOiBzdHJpbmddOiBOZXN0ZWRTdGFja1RlbXBsYXRlcyB9LFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIHNkazogU0RLLFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2xhc3NpZmllZENoYW5nZXM+IHtcbiAgY29uc3QgbmVzdGVkU3RhY2sgPSBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdO1xuICBpZiAoIW5lc3RlZFN0YWNrLnBoeXNpY2FsTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IFtdLFxuICAgICAgbm9uSG90c3dhcHBhYmxlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZToge1xuICAgICAgICAgICAgcmVhc29uOiBOb25Ib3Rzd2FwcGFibGVSZWFzb24uTkVTVEVEX1NUQUNLX0NSRUFUSU9OLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICduZXdseSBjcmVhdGVkIG5lc3RlZCBzdGFja3MgY2Fubm90IGJlIGhvdHN3YXBwZWQnLFxuICAgICAgICAgICAgc3ViamVjdDoge1xuICAgICAgICAgICAgICB0eXBlOiAnUmVzb3VyY2UnLFxuICAgICAgICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgICAgICAgIHJlc291cmNlVHlwZTogJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyxcbiAgICAgICAgICAgICAgbWV0YWRhdGE6IGV2YWx1YXRlQ2ZuVGVtcGxhdGUubWV0YWRhdGFGb3IobG9naWNhbElkKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmNyZWF0ZU5lc3RlZEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZShcbiAgICBuZXN0ZWRTdGFjay5waHlzaWNhbE5hbWUsXG4gICAgbmVzdGVkU3RhY2suZ2VuZXJhdGVkVGVtcGxhdGUsXG4gICAgY2hhbmdlLm5ld1ZhbHVlPy5Qcm9wZXJ0aWVzPy5QYXJhbWV0ZXJzLFxuICApO1xuXG4gIGNvbnN0IG5lc3RlZERpZmYgPSBjZm5fZGlmZi5mdWxsRGlmZihcbiAgICBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdLmRlcGxveWVkVGVtcGxhdGUsXG4gICAgbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXS5nZW5lcmF0ZWRUZW1wbGF0ZSxcbiAgKTtcblxuICByZXR1cm4gY2xhc3NpZnlSZXNvdXJjZUNoYW5nZXMoXG4gICAgbmVzdGVkRGlmZixcbiAgICBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlLFxuICAgIHNkayxcbiAgICBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdLm5lc3RlZFN0YWNrVGVtcGxhdGVzLFxuICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgKTtcbn1cblxuLyoqIFJldHVybnMgJ3RydWUnIGlmIGEgcGFpciBvZiBjaGFuZ2VzIGlzIGZvciB0aGUgc2FtZSByZXNvdXJjZS4gKi9cbmZ1bmN0aW9uIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UoXG4gIG9sZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBuZXdDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIG9sZENoYW5nZS5vbGRSZXNvdXJjZVR5cGUgPT09IG5ld0NoYW5nZS5uZXdSZXNvdXJjZVR5cGUgJiZcbiAgICAvLyB0aGlzIGlzbid0IGdyZWF0LCBidXQgSSBkb24ndCB3YW50IHRvIGJyaW5nIGluIHNvbWV0aGluZyBsaWtlIHVuZGVyc2NvcmUganVzdCBmb3IgdGhpcyBjb21wYXJpc29uXG4gICAgSlNPTi5zdHJpbmdpZnkob2xkQ2hhbmdlLm9sZFByb3BlcnRpZXMpID09PSBKU09OLnN0cmluZ2lmeShuZXdDaGFuZ2UubmV3UHJvcGVydGllcylcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZVJlbmFtZURpZmZlcmVuY2UoXG4gIHJlbUNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBhZGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbik6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB7XG4gIHJldHVybiBuZXcgY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlKFxuICAgIC8vIHdlIGhhdmUgdG8gZmlsbCBpbiB0aGUgb2xkIHZhbHVlLCBiZWNhdXNlIG90aGVyd2lzZSB0aGlzIHdpbGwgYmUgY2xhc3NpZmllZCBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlXG4gICAgcmVtQ2hhbmdlLm9sZFZhbHVlLFxuICAgIGFkZENoYW5nZS5uZXdWYWx1ZSxcbiAgICB7XG4gICAgICByZXNvdXJjZVR5cGU6IHtcbiAgICAgICAgb2xkVHlwZTogcmVtQ2hhbmdlLm9sZFJlc291cmNlVHlwZSxcbiAgICAgICAgbmV3VHlwZTogYWRkQ2hhbmdlLm5ld1Jlc291cmNlVHlwZSxcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0eURpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkucHJvcGVydHlEaWZmcyxcbiAgICAgIG90aGVyRGlmZnM6IChhZGRDaGFuZ2UgYXMgYW55KS5vdGhlckRpZmZzLFxuICAgIH0sXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGVgIGlmIHRoZSBjaGFuZ2UgaXMgaG90c3dhcHBhYmxlXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGBIb3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgdG8gQ0RLOjpNZXRhZGF0YVxuICogUmV0dXJucyBhIGBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGhvdHN3YXBwYWJsZVxuICovXG5mdW5jdGlvbiBpc0NhbmRpZGF0ZUZvckhvdHN3YXBwaW5nKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFJlamVjdGVkQ2hhbmdlIHwgUmVzb3VyY2VDaGFuZ2Uge1xuICAvLyBhIHJlc291cmNlIGhhcyBiZWVuIHJlbW92ZWQgT1IgYSByZXNvdXJjZSBoYXMgYmVlbiBhZGRlZDsgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IGNoYW5nZVxuICBpZiAoIWNoYW5nZS5vbGRWYWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgY2hhbmdlOiB7XG4gICAgICAgIHJlYXNvbjogTm9uSG90c3dhcHBhYmxlUmVhc29uLlJFU09VUkNFX0NSRUFUSU9OLFxuICAgICAgICBkZXNjcmlwdGlvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBjcmVhdGVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgICAgIHN1YmplY3Q6IHtcbiAgICAgICAgICB0eXBlOiAnUmVzb3VyY2UnLFxuICAgICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5uZXdWYWx1ZSEuVHlwZSxcbiAgICAgICAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihsb2dpY2FsSWQpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKCFjaGFuZ2UubmV3VmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIGNoYW5nZToge1xuICAgICAgICByZWFzb246IE5vbkhvdHN3YXBwYWJsZVJlYXNvbi5SRVNPVVJDRV9ERUxFVElPTixcbiAgICAgICAgZGVzY3JpcHRpb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyB3YXMgZGVzdHJveWVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgICAgIHN1YmplY3Q6IHtcbiAgICAgICAgICB0eXBlOiAnUmVzb3VyY2UnLFxuICAgICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5vbGRWYWx1ZS5UeXBlLFxuICAgICAgICAgIG1ldGFkYXRhOiBldmFsdWF0ZUNmblRlbXBsYXRlLm1ldGFkYXRhRm9yKGxvZ2ljYWxJZCksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvLyBhIHJlc291cmNlIGhhcyBoYWQgaXRzIHR5cGUgY2hhbmdlZFxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09IGNoYW5nZS5vbGRWYWx1ZS5UeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICBjaGFuZ2U6IHtcbiAgICAgICAgcmVhc29uOiBOb25Ib3Rzd2FwcGFibGVSZWFzb24uUkVTT1VSQ0VfVFlQRV9DSEFOR0VELFxuICAgICAgICBkZXNjcmlwdGlvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIGhhZCBpdHMgdHlwZSBjaGFuZ2VkIGZyb20gJyR7Y2hhbmdlLm9sZFZhbHVlPy5UeXBlfScgdG8gJyR7Y2hhbmdlLm5ld1ZhbHVlPy5UeXBlfSdgLFxuICAgICAgICBzdWJqZWN0OiB7XG4gICAgICAgICAgdHlwZTogJ1Jlc291cmNlJyxcbiAgICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgICAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihsb2dpY2FsSWQpLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsb2dpY2FsSWQsXG4gICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICBuZXdWYWx1ZTogY2hhbmdlLm5ld1ZhbHVlLFxuICAgIHByb3BlcnR5VXBkYXRlczogY2hhbmdlLnByb3BlcnR5VXBkYXRlcyxcbiAgICBtZXRhZGF0YTogZXZhbHVhdGVDZm5UZW1wbGF0ZS5tZXRhZGF0YUZvcihsb2dpY2FsSWQpLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBhcHBseUFsbEhvdHN3YXBPcGVyYXRpb25zKHNkazogU0RLLCBpb1NwYW46IElNZXNzYWdlU3Bhbjxhbnk+LCBob3Rzd2FwcGFibGVDaGFuZ2VzOiBIb3Rzd2FwT3BlcmF0aW9uW10pOiBQcm9taXNlPHZvaWRbXT4ge1xuICBpZiAoaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIGF3YWl0IGlvU3Bhbi5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGBcXG4ke0lDT059IGhvdHN3YXBwaW5nIHJlc291cmNlczpgKSk7XG4gIGNvbnN0IGxpbWl0ID0gcExpbWl0KDEwKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gIHJldHVybiBQcm9taXNlLmFsbChob3Rzd2FwcGFibGVDaGFuZ2VzLm1hcChob3Rzd2FwT3BlcmF0aW9uID0+IGxpbWl0KCgpID0+IHtcbiAgICByZXR1cm4gYXBwbHlIb3Rzd2FwT3BlcmF0aW9uKHNkaywgaW9TcGFuLCBob3Rzd2FwT3BlcmF0aW9uKTtcbiAgfSkpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlIb3Rzd2FwT3BlcmF0aW9uKHNkazogU0RLLCBpb1NwYW46IElNZXNzYWdlU3Bhbjxhbnk+LCBob3Rzd2FwT3BlcmF0aW9uOiBIb3Rzd2FwT3BlcmF0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIG5vdGUgdGhlIHR5cGUgb2Ygc2VydmljZSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgaG90c3dhcHBlZCBpbiB0aGUgVXNlci1BZ2VudFxuICBjb25zdCBjdXN0b21Vc2VyQWdlbnQgPSBgY2RrLWhvdHN3YXAvc3VjY2Vzcy0ke2hvdHN3YXBPcGVyYXRpb24uc2VydmljZX1gO1xuICBzZGsuYXBwZW5kQ3VzdG9tVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG4gIGNvbnN0IHJlc291cmNlVGV4dCA9IChyOiBBZmZlY3RlZFJlc291cmNlKSA9PiByLmRlc2NyaXB0aW9uID8/IGAke3IucmVzb3VyY2VUeXBlfSAnJHtyLnBoeXNpY2FsTmFtZSA/PyByLmxvZ2ljYWxJZH0nYDtcblxuICBhd2FpdCBpb1NwYW4ubm90aWZ5KElPLkNES19UT09MS0lUX0k1NDAyLm1zZyhcbiAgICBob3Rzd2FwT3BlcmF0aW9uLmNoYW5nZS5yZXNvdXJjZXMubWFwKHIgPT4gZm9ybWF0KGAgICAke0lDT059ICVzYCwgY2hhbGsuYm9sZChyZXNvdXJjZVRleHQocikpKSkuam9pbignXFxuJyksXG4gICAgaG90c3dhcE9wZXJhdGlvbi5jaGFuZ2UsXG4gICkpO1xuXG4gIC8vIGlmIHRoZSBTREsgY2FsbCBmYWlscywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gYnkgdGhlIFNES1xuICAvLyBhbmQgd2lsbCBwcmV2ZW50IHRoZSBncmVlbiAnaG90c3dhcHBlZCEnIHRleHQgZnJvbSBiZWluZyBkaXNwbGF5ZWRcbiAgdHJ5IHtcbiAgICBhd2FpdCBob3Rzd2FwT3BlcmF0aW9uLmFwcGx5KHNkayk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGlmIChlLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InIHx8IGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICBjb25zdCByZXN1bHQ6IFdhaXRlclJlc3VsdCA9IEpTT04ucGFyc2UoZm9ybWF0RXJyb3JNZXNzYWdlKGUpKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFRvb2xraXRFcnJvcihmb3JtYXRXYWl0ZXJFcnJvclJlc3VsdChyZXN1bHQpKTtcbiAgICAgIGVycm9yLm5hbWUgPSBlLm5hbWU7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxuXG4gIGF3YWl0IGlvU3Bhbi5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU0MDMubXNnKFxuICAgIGhvdHN3YXBPcGVyYXRpb24uY2hhbmdlLnJlc291cmNlcy5tYXAociA9PiBmb3JtYXQoYCAgICR7SUNPTn0gJXMgJXNgLCBjaGFsay5ib2xkKHJlc291cmNlVGV4dChyKSksIGNoYWxrLmdyZWVuKCdob3Rzd2FwcGVkIScpKSkuam9pbignXFxuJyksXG4gICAgaG90c3dhcE9wZXJhdGlvbi5jaGFuZ2UsXG4gICkpO1xuXG4gIHNkay5yZW1vdmVDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2FpdGVyRXJyb3JSZXN1bHQocmVzdWx0OiBXYWl0ZXJSZXN1bHQpIHtcbiAgY29uc3QgbWFpbiA9IFtcbiAgICBgUmVzb3VyY2UgaXMgbm90IGluIHRoZSBleHBlY3RlZCBzdGF0ZSBkdWUgdG8gd2FpdGVyIHN0YXR1czogJHtyZXN1bHQuc3RhdGV9YCxcbiAgICByZXN1bHQucmVhc29uID8gYCR7cmVzdWx0LnJlYXNvbn0uYCA6ICcnLFxuICBdLmpvaW4oJy4gJyk7XG5cbiAgaWYgKHJlc3VsdC5vYnNlcnZlZFJlc3BvbnNlcyAhPSBudWxsKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZWRSZXNwb25zZXMgPSBPYmplY3RcbiAgICAgIC5lbnRyaWVzKHJlc3VsdC5vYnNlcnZlZFJlc3BvbnNlcylcbiAgICAgIC5tYXAoKFttc2csIGNvdW50XSkgPT4gYCAgLSAke21zZ30gKCR7Y291bnR9KWApXG4gICAgICAuam9pbignXFxuJyk7XG5cbiAgICByZXR1cm4gYCR7bWFpbn0gT2JzZXJ2ZWQgcmVzcG9uc2VzOlxcbiR7b2JzZXJ2ZWRSZXNwb25zZXN9YDtcbiAgfVxuXG4gIHJldHVybiBtYWluO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2dSZWplY3RlZENoYW5nZXMoXG4gIGlvU3BhbjogSU1lc3NhZ2VTcGFuPGFueT4sXG4gIHJlamVjdGVkQ2hhbmdlczogUmVqZWN0ZWRDaGFuZ2VbXSxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGlmIChyZWplY3RlZENoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBFS1MgU2VydmljZXMgY2FuIGhhdmUgYSB0YXNrIGRlZmluaXRpb24gdGhhdCBkb2Vzbid0IHJlZmVyIHRvIHRoZSB0YXNrIGRlZmluaXRpb24gYmVpbmcgdXBkYXRlZC5cbiAgICogV2UgaGF2ZSB0byBsb2cgdGhpcyBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlIHRvIHRoZSB0YXNrIGRlZmluaXRpb24sIGJ1dCB3aGVuIHdlIGRvLFxuICAgKiB3ZSB3aW5kIHVwIGhvdHN3YXBwaW5nIHRoZSB0YXNrIGRlZmluaXRpb24gYW5kIGxvZ2dpbmcgaXQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZS5cbiAgICpcbiAgICogVGhpcyBsb2dpYyBwcmV2ZW50cyB1cyBmcm9tIGxvZ2dpbmcgdGhhdCBjaGFuZ2UgYXMgbm9uLWhvdHN3YXBwYWJsZSB3aGVuIHdlIGhvdHN3YXAgaXQuXG4gICAqL1xuICBpZiAoaG90c3dhcE1vZGUgPT09ICdob3Rzd2FwLW9ubHknKSB7XG4gICAgcmVqZWN0ZWRDaGFuZ2VzID0gcmVqZWN0ZWRDaGFuZ2VzLmZpbHRlcigoY2hhbmdlKSA9PiBjaGFuZ2UuaG90c3dhcE9ubHlWaXNpYmxlID09PSB0cnVlKTtcblxuICAgIGlmIChyZWplY3RlZENoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWVzc2FnZXMgPSBbJyddOyAvLyBzdGFydCB3aXRoIGVtcHR5IGxpbmVcblxuICBpZiAoaG90c3dhcE1vZGUgPT09ICdob3Rzd2FwLW9ubHknKSB7XG4gICAgbWVzc2FnZXMucHVzaChmb3JtYXQoJyVzICVzJywgY2hhbGsucmVkKCfimqDvuI8nKSwgY2hhbGsucmVkKCdUaGUgZm9sbG93aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyB3ZXJlIGZvdW5kLiBUbyByZWNvbmNpbGUgdGhlc2UgdXNpbmcgQ2xvdWRGb3JtYXRpb24sIHNwZWNpZnkgLS1ob3Rzd2FwLWZhbGxiYWNrJykpKTtcbiAgfSBlbHNlIHtcbiAgICBtZXNzYWdlcy5wdXNoKGZvcm1hdCgnJXMgJXMnLCBjaGFsay5yZWQoJ+KaoO+4jycpLCBjaGFsay5yZWQoJ1RoZSBmb2xsb3dpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIHdlcmUgZm91bmQ6JykpKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgeyBjaGFuZ2UgfSBvZiByZWplY3RlZENoYW5nZXMpIHtcbiAgICBtZXNzYWdlcy5wdXNoKCcgICAgJyArIG5vbkhvdHN3YXBwYWJsZUNoYW5nZU1lc3NhZ2UoY2hhbmdlKSk7XG4gIH1cbiAgbWVzc2FnZXMucHVzaCgnJyk7IC8vIG5ld2xpbmVcblxuICBhd2FpdCBpb1NwYW4ubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9JTkZPLm1zZyhtZXNzYWdlcy5qb2luKCdcXG4nKSkpO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgYSBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VcbiAqL1xuZnVuY3Rpb24gbm9uSG90c3dhcHBhYmxlQ2hhbmdlTWVzc2FnZShjaGFuZ2U6IE5vbkhvdHN3YXBwYWJsZUNoYW5nZSk6IHN0cmluZyB7XG4gIGNvbnN0IHN1YmplY3QgPSBjaGFuZ2Uuc3ViamVjdDtcbiAgY29uc3QgcmVhc29uID0gY2hhbmdlLmRlc2NyaXB0aW9uID8/IGNoYW5nZS5yZWFzb247XG5cbiAgc3dpdGNoIChzdWJqZWN0LnR5cGUpIHtcbiAgICBjYXNlICdPdXRwdXQnOlxuICAgICAgcmV0dXJuIGZvcm1hdChcbiAgICAgICAgJ291dHB1dDogJXMsIHJlYXNvbjogJXMnLFxuICAgICAgICBjaGFsay5ib2xkKHN1YmplY3QubG9naWNhbElkKSxcbiAgICAgICAgY2hhbGsucmVkKHJlYXNvbiksXG4gICAgICApO1xuICAgIGNhc2UgJ1Jlc291cmNlJzpcbiAgICAgIHJldHVybiBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZU1lc3NhZ2Uoc3ViamVjdCwgcmVhc29uKTtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdHMgYSBub24taG90c3dhcHBhYmxlIHJlc291cmNlIHN1YmplY3RcbiAqL1xuZnVuY3Rpb24gbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VNZXNzYWdlKHN1YmplY3Q6IFJlc291cmNlU3ViamVjdCwgcmVhc29uOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoc3ViamVjdC5yZWplY3RlZFByb3BlcnRpZXM/Lmxlbmd0aCkge1xuICAgIHJldHVybiBmb3JtYXQoXG4gICAgICAncmVzb3VyY2U6ICVzLCB0eXBlOiAlcywgcmVqZWN0ZWQgY2hhbmdlczogJXMsIHJlYXNvbjogJXMnLFxuICAgICAgY2hhbGsuYm9sZChzdWJqZWN0LmxvZ2ljYWxJZCksXG4gICAgICBjaGFsay5ib2xkKHN1YmplY3QucmVzb3VyY2VUeXBlKSxcbiAgICAgIGNoYWxrLmJvbGQoc3ViamVjdC5yZWplY3RlZFByb3BlcnRpZXMpLFxuICAgICAgY2hhbGsucmVkKHJlYXNvbiksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXQoXG4gICAgJ3Jlc291cmNlOiAlcywgdHlwZTogJXMsIHJlYXNvbjogJXMnLFxuICAgIGNoYWxrLmJvbGQoc3ViamVjdC5sb2dpY2FsSWQpLFxuICAgIGNoYWxrLmJvbGQoc3ViamVjdC5yZXNvdXJjZVR5cGUpLFxuICAgIGNoYWxrLnJlZChyZWFzb24pLFxuICApO1xufVxuIl19