"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const util_1 = require("util");
const chalk = require("chalk");
const bootstrap_props_1 = require("./bootstrap/bootstrap-props");
const cfn_api_1 = require("./deployments/cfn-api");
const api_1 = require("../../../@aws-cdk/tmp-toolkit-helpers/src/api");
const private_1 = require("../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 */
class ToolkitInfo {
    static determineName(overrideName) {
        return overrideName ?? exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    static async lookup(environment, sdk, ioHelper, stackName) {
        const cfn = sdk.cloudFormation();
        stackName = ToolkitInfo.determineName(stackName);
        try {
            const stack = await (0, cfn_api_1.stabilizeStack)(cfn, ioHelper, stackName);
            if (!stack) {
                await ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_DEBUG.msg((0, util_1.format)("The environment %s doesn't have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.", environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`))));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            if (stack.stackStatus.isCreationFailure) {
                // Treat a "failed to create" bootstrap stack as an absent one.
                await ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_DEBUG.msg((0, util_1.format)('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`))));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            return new ExistingToolkitInfo(stack);
        }
        catch (e) {
            return ToolkitInfo.bootstrapStackLookupError(stackName, e);
        }
    }
    static fromStack(stack) {
        return new ExistingToolkitInfo(stack);
    }
    static bootstrapStackNotFoundInfo(stackName) {
        return new BootstrapStackNotFoundInfo(stackName, "This deployment requires a bootstrap stack with a known name; pass '--toolkit-stack-name' or switch to using the 'DefaultStackSynthesizer' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)");
    }
    static bootstrapStackLookupError(stackName, e) {
        return new BootstrapStackNotFoundInfo(stackName, `This deployment requires a bootstrap stack with a known name, but during its lookup the following error occurred: ${e}; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
    }
    constructor() {
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack) {
        super();
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_props_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_props_1.BUCKET_NAME_OUTPUT);
    }
    get repositoryName() {
        return this.requireOutput(bootstrap_props_1.REPOSITORY_NAME_OUTPUT);
    }
    get version() {
        return parseInt(this.bootstrapStack.outputs[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT] ?? '0', 10);
    }
    get variant() {
        return this.bootstrapStack.parameters[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER] ?? bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
    }
    get parameters() {
        return this.bootstrapStack.parameters ?? {};
    }
    get terminationProtection() {
        return this.bootstrapStack.terminationProtection ?? false;
    }
    get stackName() {
        return this.bootstrapStack.stackName;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     */
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new api_1.ToolkitError(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(stackName, errorMessage) {
        super();
        this.stackName = stackName;
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    get bucketUrl() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    get bucketName() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    get repositoryName() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    get version() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    get variant() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
    prepareEcrRepository() {
        throw new api_1.ToolkitError(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUE4QjtBQUU5QiwrQkFBK0I7QUFFL0IsaUVBT3FDO0FBRXJDLG1EQUF1RDtBQUN2RCx1RUFBNkU7QUFDN0Usc0ZBQTZGO0FBRWhGLFFBQUEsMEJBQTBCLEdBQUcsWUFBWSxDQUFDO0FBRXZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBc0IsV0FBVztJQUN4QixNQUFNLENBQUMsYUFBYSxDQUFDLFlBQXFCO1FBQy9DLE9BQU8sWUFBWSxJQUFJLGtDQUEwQixDQUFDO0lBQ3BELENBQUM7SUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FDeEIsV0FBOEIsRUFDOUIsR0FBUSxFQUNSLFFBQWtCLEVBQ2xCLFNBQTZCO1FBRTdCLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNqQyxTQUFTLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUM7WUFDSCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUEsd0JBQWMsRUFBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzdELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDWCxNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FDaEQsSUFBQSxhQUFNLEVBQ0osa0lBQWtJLEVBQ2xJLFdBQVcsQ0FBQyxJQUFJLEVBQ2hCLFNBQVMsRUFDVCxLQUFLLENBQUMsSUFBSSxDQUFDLGtCQUFrQixXQUFXLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FDbEQsQ0FDRixDQUFDLENBQUM7Z0JBQ0gsT0FBTyxXQUFXLENBQUMsMEJBQTBCLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDM0QsQ0FBQztZQUNE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Y3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB0eXBlIHsgU0RLIH0gZnJvbSAnLi9hd3MtYXV0aCc7XG5pbXBvcnQge1xuICBCT09UU1RSQVBfVkFSSUFOVF9QQVJBTUVURVIsXG4gIEJPT1RTVFJBUF9WRVJTSU9OX09VVFBVVCxcbiAgQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCxcbiAgQlVDS0VUX05BTUVfT1VUUFVULFxuICBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5ULFxuICBSRVBPU0lUT1JZX05BTUVfT1VUUFVULFxufSBmcm9tICcuL2Jvb3RzdHJhcC9ib290c3RyYXAtcHJvcHMnO1xuaW1wb3J0IHR5cGUgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBzdGFiaWxpemVTdGFjayB9IGZyb20gJy4vZGVwbG95bWVudHMvY2ZuLWFwaSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGknO1xuaW1wb3J0IHsgSU8sIHR5cGUgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RPT0xLSVRfU1RBQ0tfTkFNRSA9ICdDREtUb29sa2l0JztcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgQm9vdHN0cmFwIHN0YWNrIG9mIHRoZSBlbnZpcm9ubWVudCB3ZSdyZSBkZXBsb3lpbmcgdG8uXG4gKlxuICogVGhpcyBjbGFzcyBzZXJ2ZXMgdG86XG4gKlxuICogLSBJbnNwZWN0IHRoZSBib290c3RyYXAgc3RhY2ssIGFuZCByZXR1cm4gdmFyaW91cyBwcm9wZXJ0aWVzIG9mIGl0IGZvciBzdWNjZXNzZnVsXG4gKiAgIGFzc2V0IGRlcGxveW1lbnQgKGluIGNhc2Ugb2YgbGVnYWN5LXN5bnRoZXNpemVkIHN0YWNrcykuXG4gKiAtIFZhbGlkYXRlIHRoZSB2ZXJzaW9uIG9mIHRoZSB0YXJnZXQgZW52aXJvbm1lbnQsIGFuZCBub3RoaW5nIGVsc2UgKGluIGNhc2Ugb2ZcbiAqICAgZGVmYXVsdC1zeW50aGVzaXplZCBzdGFja3MpLlxuICpcbiAqIEFuIG9iamVjdCBvZiB0aGlzIHR5cGUgbWlnaHQgcmVwcmVzZW50IGEgYm9vdHN0cmFwIHN0YWNrIHRoYXQgY291bGQgbm90IGJlIGZvdW5kLlxuICogVGhpcyBpcyBub3QgYW4gaXNzdWUgdW5sZXNzIGFueSBtZW1iZXJzIGFyZSB1c2VkIHRoYXQgcmVxdWlyZSB0aGUgYm9vdHN0cmFwIHN0YWNrXG4gKiB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgYW4gZXJyb3IgaXMgdGhyb3duIChkZWZhdWx0LXN5bnRoZXNpemVkIHN0YWNrc1xuICogc2hvdWxkIG5ldmVyIHJ1biBpbnRvIHRoaXMgYXMgdGhleSBkb24ndCBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIGJvb3RzdHJhcFxuICogc3RhY2ssIGFsbCBpbmZvcm1hdGlvbiBpcyBhbHJlYWR5IGVuY29kZWQgaW50byB0aGUgQ2xvdWQgQXNzZW1ibHkgTWFuaWZlc3QpLlxuICpcbiAqIE5ldmVydGhlbGVzcywgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBleGlzdHMgdG8gc2VydmUgYXMgYSBjYWNoZSBmb3IgU1NNXG4gKiBwYXJhbWV0ZXIgbG9va3VwcyAob3RoZXJ3aXNlLCB0aGUgXCJib290c3RyYXAgc3RhY2sgdmVyc2lvblwiIHBhcmFtZXRlciB3b3VsZFxuICogbmVlZCB0byBiZSByZWFkIHJlcGVhdGVkbHkpLlxuICpcbiAqIENhbGxlZCBcIlRvb2xraXRJbmZvXCIgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyBzdGF0aWMgZGV0ZXJtaW5lTmFtZShvdmVycmlkZU5hbWU/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNkazogU0RLLFxuICAgIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgICBzdGFja05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxUb29sa2l0SW5mbz4ge1xuICAgIGNvbnN0IGNmbiA9IHNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIHN0YWNrTmFtZSA9IFRvb2xraXRJbmZvLmRldGVybWluZU5hbWUoc3RhY2tOYW1lKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIGlvSGVscGVyLCBzdGFja05hbWUpO1xuICAgICAgaWYgKCFzdGFjaykge1xuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhcbiAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICBcIlRoZSBlbnZpcm9ubWVudCAlcyBkb2Vzbid0IGhhdmUgdGhlIENESyB0b29sa2l0IHN0YWNrICglcykgaW5zdGFsbGVkLiBVc2UgJXMgdG8gc2V0dXAgeW91ciBlbnZpcm9ubWVudCBmb3IgdXNlIHdpdGggdGhlIHRvb2xraXQuXCIsXG4gICAgICAgICAgICBlbnZpcm9ubWVudC5uYW1lLFxuICAgICAgICAgICAgc3RhY2tOYW1lLFxuICAgICAgICAgICAgY2hhbGsuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApLFxuICAgICAgICAgICksXG4gICAgICAgICkpO1xuICAgICAgICByZXR1cm4gVG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oc3RhY2tOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFjay5zdGFja1N0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgICAgICAvLyBUcmVhdCBhIFwiZmFpbGVkIHRvIGNyZWF0ZVwiIGJvb3RzdHJhcCBzdGFjayBhcyBhbiBhYnNlbnQgb25lLlxuICAgICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0RFQlVHLm1zZyhcbiAgICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgICAnVGhlIGVudmlyb25tZW50ICVzIGhhcyBhIENESyB0b29sa2l0IHN0YWNrICglcykgdGhhdCBmYWlsZWQgdG8gY3JlYXRlLiBVc2UgJXMgdG8gdHJ5IHByb3Zpc2lvbmluZyBpdCBhZ2Fpbi4nLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQubmFtZSxcbiAgICAgICAgICAgIHN0YWNrTmFtZSxcbiAgICAgICAgICAgIGNoYWxrLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSxcbiAgICAgICAgICApLFxuICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuIFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHN0YWNrTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRXhpc3RpbmdUb29sa2l0SW5mbyhzdGFjayk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICByZXR1cm4gVG9vbGtpdEluZm8uYm9vdHN0cmFwU3RhY2tMb29rdXBFcnJvcihzdGFja05hbWUsIGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YWNrKHN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrKTogVG9vbGtpdEluZm8ge1xuICAgIHJldHVybiBuZXcgRXhpc3RpbmdUb29sa2l0SW5mbyhzdGFjayk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHN0YWNrTmFtZTogc3RyaW5nKTogVG9vbGtpdEluZm8ge1xuICAgIHJldHVybiBuZXcgQm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8oXG4gICAgICBzdGFja05hbWUsXG4gICAgICBcIlRoaXMgZGVwbG95bWVudCByZXF1aXJlcyBhIGJvb3RzdHJhcCBzdGFjayB3aXRoIGEga25vd24gbmFtZTsgcGFzcyAnLS10b29sa2l0LXN0YWNrLW5hbWUnIG9yIHN3aXRjaCB0byB1c2luZyB0aGUgJ0RlZmF1bHRTdGFja1N5bnRoZXNpemVyJyAoc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvbGF0ZXN0L2d1aWRlL2Jvb3RzdHJhcHBpbmcuaHRtbClcIixcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBib290c3RyYXBTdGFja0xvb2t1cEVycm9yKHN0YWNrTmFtZTogc3RyaW5nLCBlOiBFcnJvcik6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKFxuICAgICAgc3RhY2tOYW1lLFxuICAgICAgYFRoaXMgZGVwbG95bWVudCByZXF1aXJlcyBhIGJvb3RzdHJhcCBzdGFjayB3aXRoIGEga25vd24gbmFtZSwgYnV0IGR1cmluZyBpdHMgbG9va3VwIHRoZSBmb2xsb3dpbmcgZXJyb3Igb2NjdXJyZWQ6ICR7ZX07IHBhc3MgXFwnLS10b29sa2l0LXN0YWNrLW5hbWVcXCcgb3Igc3dpdGNoIHRvIHVzaW5nIHRoZSBcXCdEZWZhdWx0U3RhY2tTeW50aGVzaXplclxcJyAoc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvbGF0ZXN0L2d1aWRlL2Jvb3RzdHJhcHBpbmcuaHRtbClgLFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgZm91bmQ6IGJvb2xlYW47XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBidWNrZXRVcmw6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcG9zaXRvcnlOYW1lOiBzdHJpbmc7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSB2ZXJzaW9uOiBudW1iZXI7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSB2YXJpYW50OiBzdHJpbmc7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBib290c3RyYXBTdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaztcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGJvb3RzdHJhcCBzdGFjayBpcyBmb3VuZFxuICovXG5jbGFzcyBFeGlzdGluZ1Rvb2xraXRJbmZvIGV4dGVuZHMgVG9vbGtpdEluZm8ge1xuICBwdWJsaWMgcmVhZG9ubHkgZm91bmQgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBib290c3RyYXBTdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaykge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldFVybCgpIHtcbiAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnJlcXVpcmVPdXRwdXQoQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCl9YDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlT3V0cHV0KEJVQ0tFVF9OQU1FX09VVFBVVCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHJlcG9zaXRvcnlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVPdXRwdXQoUkVQT1NJVE9SWV9OQU1FX09VVFBVVCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVRdID8/ICcwJywgMTApO1xuICB9XG5cbiAgcHVibGljIGdldCB2YXJpYW50KCkge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnBhcmFtZXRlcnNbQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSXSA/PyBERUZBVUxUX0JPT1RTVFJBUF9WQVJJQU5UO1xuICB9XG5cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnBhcmFtZXRlcnMgPz8ge307XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN0YWNrTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLnN0YWNrTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGFuIEVDUiByZXBvc2l0b3J5IGZvciB1cGxvYWRpbmcgdG8gdXNpbmcgRG9ja2VyXG4gICAqXG4gICAqL1xuICBwcml2YXRlIHJlcXVpcmVPdXRwdXQob3V0cHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghKG91dHB1dCBpbiB0aGlzLmJvb3RzdHJhcFN0YWNrLm91dHB1dHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICBgVGhlIENESyB0b29sa2l0IHN0YWNrICgke3RoaXMuYm9vdHN0cmFwU3RhY2suc3RhY2tOYW1lfSkgZG9lcyBub3QgaGF2ZSBhbiBvdXRwdXQgbmFtZWQgJHtvdXRwdXR9LiBVc2UgJ2NkayBib290c3RyYXAnIHRvIGNvcnJlY3QgdGhpcy5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sub3V0cHV0c1tvdXRwdXRdO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuZWQgd2hlbiBhIGJvb3RzdHJhcCBzdGFjayBjb3VsZCBub3QgYmUgZm91bmRcbiAqXG4gKiBUaGlzIGlzIG5vdCBhbiBlcnJvciBpbiBwcmluY2lwbGUsIFVOVElMIG9uZSBvZiB0aGUgbWVtYmVycyBpcyBjYWxsZWQgdGhhdCByZXF1aXJlc1xuICogdGhlIGJvb3RzdHJhcCBzdGFjayB0byBoYXZlIGJlZW4gZm91bmQsIGluIHdoaWNoIGNhc2UgdGhlIGxvb2t1cCBlcnJvciBpcyBzdGlsbCB0aHJvd25cbiAqIGJlbGF0ZWRseS5cbiAqXG4gKiBUaGUgZXJyb3JzIGJlbG93IHNlcnZlIGFzIGEgbGFzdCBzdG9wLWdhcCBtZXNzYWdlLS1ub3JtYWxseSBjYWxsaW5nIGNvZGUgc2hvdWxkIGhhdmVcbiAqIGNoZWNrZWQgYHRvb2xraXQuZm91bmRgIGFuZCBwcm9kdWNlZCBhbiBhcHByb3ByaWF0ZSBlcnJvciBtZXNzYWdlLlxuICovXG5jbGFzcyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXJyb3JNZXNzYWdlOiBzdHJpbmcsXG4gICkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJvb3RzdHJhcFN0YWNrKCk6IENsb3VkRm9ybWF0aW9uU3RhY2sge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXRVcmwoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCByZXBvc2l0b3J5TmFtZSgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCB2ZXJzaW9uKCk6IG51bWJlciB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhcmlhbnQoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBwcmVwYXJlRWNyUmVwb3NpdG9yeSgpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFY3JSZXBvc2l0b3J5SW5mbyB7XG4gIHJlcG9zaXRvcnlVcmk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFY3JDcmVkZW50aWFscyB7XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGVuZHBvaW50OiBzdHJpbmc7XG59XG4iXX0=