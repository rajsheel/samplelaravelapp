"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackActivityMonitor = void 0;
const util = require("util");
const uuid = require("uuid");
const stack_event_poller_1 = require("./stack-event-poller");
const resource_metadata_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/resource-metadata/resource-metadata");
const util_1 = require("../../util");
const stack_progress_monitor_1 = require("./stack-progress-monitor");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
class StackActivityMonitor {
    constructor({ cfn, ioHelper, stack, stackName, resourcesTotal, changeSetCreationTime, pollingInterval = 2000, }) {
        this.errors = [];
        this.ioHelper = ioHelper;
        this.stack = stack;
        this.stackName = stackName;
        this.progressMonitor = new stack_progress_monitor_1.StackProgressMonitor(resourcesTotal);
        this.pollingInterval = pollingInterval;
        this.poller = new stack_event_poller_1.StackEventPoller(cfn, {
            stackName,
            startTime: changeSetCreationTime?.getTime() ?? Date.now(),
        });
    }
    async start() {
        this.monitorId = uuid.v4();
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5501.msg(`Deploying ${this.stackName}`, {
            deployment: this.monitorId,
            stack: this.stack,
            stackName: this.stackName,
            resourcesTotal: this.progressMonitor.total,
        }));
        this.scheduleNextTick();
        return this;
    }
    async stop() {
        const oldMonitorId = this.monitorId;
        this.monitorId = undefined;
        if (this.tickTimer) {
            clearTimeout(this.tickTimer);
        }
        // Do a final poll for all events. This is to handle the situation where DescribeStackStatus
        // already returned an error, but the monitor hasn't seen all the events yet and we'd end
        // up not printing the failure reason to users.
        await this.finalPollToEnd(oldMonitorId);
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5503.msg(`Completed ${this.stackName}`, {
            deployment: oldMonitorId,
            stack: this.stack,
            stackName: this.stackName,
            resourcesTotal: this.progressMonitor.total,
        }));
    }
    scheduleNextTick() {
        if (!this.monitorId) {
            return;
        }
        this.tickTimer = setTimeout(() => void this.tick(), this.pollingInterval);
    }
    async tick() {
        if (!this.monitorId) {
            return;
        }
        try {
            this.readPromise = this.readNewEvents(this.monitorId);
            await this.readPromise;
            this.readPromise = undefined;
            // We might have been stop()ped while the network call was in progress.
            if (!this.monitorId) {
                return;
            }
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E5500.msg(util.format('Error occurred while monitoring stack: %s', e), { error: e }));
        }
        this.scheduleNextTick();
    }
    findMetadataFor(logicalId) {
        const metadata = this.stack.manifest?.metadata;
        if (!logicalId || !metadata) {
            return undefined;
        }
        return (0, resource_metadata_1.resourceMetadata)(this.stack, logicalId);
    }
    /**
     * Reads all new events from the stack history
     *
     * The events are returned in reverse chronological order; we continue to the next page if we
     * see a next page and the last event in the page is new to us (and within the time window).
     * haven't seen the final event
     */
    async readNewEvents(monitorId) {
        const pollEvents = await this.poller.poll();
        for (const resourceEvent of pollEvents) {
            this.progressMonitor.process(resourceEvent.event);
            const activity = {
                deployment: monitorId,
                event: resourceEvent.event,
                metadata: this.findMetadataFor(resourceEvent.event.LogicalResourceId),
                progress: this.progressMonitor.progress,
            };
            this.checkForErrors(activity);
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5502.msg(this.formatActivity(activity, true), activity));
        }
    }
    /**
     * Perform a final poll to the end and flush out all events to the printer
     *
     * Finish any poll currently in progress, then do a final one until we've
     * reached the last page.
     */
    async finalPollToEnd(monitorId) {
        // If we were doing a poll, finish that first. It was started before
        // the moment we were sure we weren't going to get any new events anymore
        // so we need to do a new one anyway. Need to wait for this one though
        // because our state is single-threaded.
        if (this.readPromise) {
            await this.readPromise;
        }
        await this.readNewEvents(monitorId);
    }
    /**
     * Formats a stack activity into a basic string
     */
    formatActivity(activity, progress) {
        const event = activity.event;
        const metadata = activity.metadata;
        const resourceName = metadata ? metadata.constructPath : event.LogicalResourceId || '';
        const logicalId = resourceName !== event.LogicalResourceId ? `(${event.LogicalResourceId}) ` : '';
        return util.format('%s | %s%s | %s | %s | %s %s%s%s', event.StackName, progress !== false ? `${activity.progress.formatted} | ` : '', new Date(event.Timestamp).toLocaleTimeString(), event.ResourceStatus || '', event.ResourceType, resourceName, logicalId, event.ResourceStatusReason ? event.ResourceStatusReason : '', metadata?.entry.trace ? `\n\t${metadata.entry.trace.join('\n\t\\_ ')}` : '');
    }
    checkForErrors(activity) {
        if ((0, util_1.stackEventHasErrorMessage)(activity.event.ResourceStatus ?? '')) {
            const isCancelled = (activity.event.ResourceStatusReason ?? '').indexOf('cancelled') > -1;
            // Cancelled is not an interesting failure reason, nor is the stack message (stack
            // message will just say something like "stack failed to update")
            if (!isCancelled && activity.event.StackName !== activity.event.LogicalResourceId) {
                this.errors.push(activity.event.ResourceStatusReason ?? '');
            }
        }
    }
}
exports.StackActivityMonitor = StackActivityMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stYWN0aXZpdHktbW9uaXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInN0YWNrLWFjdGl2aXR5LW1vbml0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNkJBQTZCO0FBRzdCLDZCQUE2QjtBQUM3Qiw2REFBd0Q7QUFDeEQsNEhBQXdIO0FBQ3hILHFDQUF1RDtBQUV2RCxxRUFBZ0U7QUFDaEUseUZBQWdHO0FBdURoRyxNQUFhLG9CQUFvQjtJQWdDL0IsWUFBWSxFQUNWLEdBQUcsRUFDSCxRQUFRLEVBQ1IsS0FBSyxFQUNMLFNBQVMsRUFDVCxjQUFjLEVBQ2QscUJBQXFCLEVBQ3JCLGVBQWUsR0FBRyxJQUFLLEdBQ0c7UUE1QlosV0FBTSxHQUFhLEVBQUUsQ0FBQztRQTZCcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFFM0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLDZDQUFvQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ2hFLElBQUksQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxxQ0FBZ0IsQ0FBQyxHQUFHLEVBQUU7WUFDdEMsU0FBUztZQUNULFNBQVMsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1NBQzFELENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSztRQUNoQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUMzQixNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsYUFBYSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDakYs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Q0FBQyxDQUFDLENBQUM7WUFFMUYsa0ZBQWtGO1lBQ2xGLGlFQUFpRTtZQUNqRSxJQUFJLENBQUMsV0FBVyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDbEYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUM5RCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7Q0FDRjtBQTFNRCxvREEwTUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgdHlwZSB7IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgdHlwZSB7IFN0YWNrQWN0aXZpdHkgfSBmcm9tICdAYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBTdGFja0V2ZW50UG9sbGVyIH0gZnJvbSAnLi9zdGFjay1ldmVudC1wb2xsZXInO1xuaW1wb3J0IHsgcmVzb3VyY2VNZXRhZGF0YSB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9yZXNvdXJjZS1tZXRhZGF0YS9yZXNvdXJjZS1tZXRhZGF0YSc7XG5pbXBvcnQgeyBzdGFja0V2ZW50SGFzRXJyb3JNZXNzYWdlIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IElDbG91ZEZvcm1hdGlvbkNsaWVudCB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IFN0YWNrUHJvZ3Jlc3NNb25pdG9yIH0gZnJvbSAnLi9zdGFjay1wcm9ncmVzcy1tb25pdG9yJztcbmltcG9ydCB7IElPLCB0eXBlIElvSGVscGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vQGF3cy1jZGsvdG1wLXRvb2xraXQtaGVscGVycy9zcmMvYXBpL2lvL3ByaXZhdGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrQWN0aXZpdHlNb25pdG9yUHJvcHMge1xuICAvKipcbiAgICogVGhlIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICAgKi9cbiAgcmVhZG9ubHkgY2ZuOiBJQ2xvdWRGb3JtYXRpb25DbGllbnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBJb0hlbHBlciB1c2VkIGZvciBtZXNzYWdpbmdcbiAgICovXG4gIHJlYWRvbmx5IGlvSGVscGVyOiBJb0hlbHBlcjtcblxuICAvKipcbiAgICogVGhlIHN0YWNrIGFydGlmYWN0IHRoYXQgaXMgZ2V0dGluZyBkZXBsb3llZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoYXQgaXMgZ2V0dGluZyBkZXBsb3llZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiByZXNvdXJjZXMgdG8gdXBkYXRlXG4gICAqXG4gICAqIFVzZWQgdG8gY2FsY3VsYXRlIGEgcHJvZ3Jlc3MgYmFyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIE5vIHByb2dyZXNzIHJlcG9ydGluZy5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlc1RvdGFsPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGlvbiB0aW1lIG9mIHRoZSBjaGFuZ2Ugc2V0XG4gICAqXG4gICAqIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGZpbHRlciBldmVudHMsIG9ubHkgc2hvd2luZyB0aG9zZSBmcm9tIGFmdGVyIHRoZSBjaGFuZ2VcbiAgICogc2V0IGNyZWF0aW9uIHRpbWUuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzLCBvdGhlcndpc2UgdGhlIGZpbHRlcmluZyB3aWxsIGJlIHN1YmplY3RcbiAgICogdG8gY2xvY2sgZHJpZnQgYmV0d2VlbiBsb2NhbCBhbmQgY2xvdWQgbWFjaGluZXMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbG9jYWwgbWFjaGluZSdzIGN1cnJlbnQgdGltZVxuICAgKi9cbiAgcmVhZG9ubHkgY2hhbmdlU2V0Q3JlYXRpb25UaW1lPzogRGF0ZTtcblxuICAvKipcbiAgICogVGltZSB0byB3YWl0IGJldHdlZW4gZmV0Y2hpbmcgbmV3IGFjdGl2aXRpZXMuXG4gICAqXG4gICAqIE11c3Qgd2FpdCBhIHJlYXNvbmFibGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiBwb2xscywgc2luY2Ugd2UgbmVlZCB0byBjb25zaWRlciBDbG91ZEZvcm1hdGlvbiBBUEkgbGltaXRzXG4gICAqXG4gICAqIEBkZWZhdWx0IDJfMDAwXG4gICAqL1xuICByZWFkb25seSBwb2xsaW5nSW50ZXJ2YWw/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja0FjdGl2aXR5TW9uaXRvciB7XG4gIC8qKlxuICAgKiBUaGUgcG9sbGVyIHVzZWQgdG8gcmVhZCBzdGFjayBldmVudHNcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcG9sbGVyOiBTdGFja0V2ZW50UG9sbGVyO1xuXG4gIC8qKlxuICAgKiBGZXRjaCBuZXcgYWN0aXZpdHkgZXZlcnkgMSBzZWNvbmRcbiAgICogUHJpbnRlcnMgY2FuIGRlY2lkZSB0byB1cGRhdGUgYSB2aWV3IGxlc3MgZnJlcXVlbnRseSBpZiBkZXNpcmVkXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHBvbGxpbmdJbnRlcnZhbDogbnVtYmVyO1xuXG4gIHB1YmxpYyByZWFkb25seSBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgcHJpdmF0ZSBtb25pdG9ySWQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBwcm9ncmVzc01vbml0b3I6IFN0YWNrUHJvZ3Jlc3NNb25pdG9yO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHRpY2sgdGltZXJcbiAgICovXG4gIHByaXZhdGUgdGlja1RpbWVyPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG5cbiAgLyoqXG4gICAqIFNldCB0byB0aGUgYWN0aXZpdHkgb2YgcmVhZGluZyB0aGUgY3VycmVudCBldmVudHNcbiAgICovXG4gIHByaXZhdGUgcmVhZFByb21pc2U/OiBQcm9taXNlPGFueT47XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2ZuLFxuICAgIGlvSGVscGVyLFxuICAgIHN0YWNrLFxuICAgIHN0YWNrTmFtZSxcbiAgICByZXNvdXJjZXNUb3RhbCxcbiAgICBjaGFuZ2VTZXRDcmVhdGlvblRpbWUsXG4gICAgcG9sbGluZ0ludGVydmFsID0gMl8wMDAsXG4gIH06IFN0YWNrQWN0aXZpdHlNb25pdG9yUHJvcHMpIHtcbiAgICB0aGlzLmlvSGVscGVyID0gaW9IZWxwZXI7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuc3RhY2tOYW1lID0gc3RhY2tOYW1lO1xuXG4gICAgdGhpcy5wcm9ncmVzc01vbml0b3IgPSBuZXcgU3RhY2tQcm9ncmVzc01vbml0b3IocmVzb3VyY2VzVG90YWwpO1xuICAgIHRoaXMucG9sbGluZ0ludGVydmFsID0gcG9sbGluZ0ludGVydmFsO1xuICAgIHRoaXMucG9sbGVyID0gbmV3IFN0YWNrRXZlbnRQb2xsZXIoY2ZuLCB7XG4gICAgICBzdGFja05hbWUsXG4gICAgICBzdGFydFRpbWU6IGNoYW5nZVNldENyZWF0aW9uVGltZT8uZ2V0VGltZSgpID8/IERhdGUubm93KCksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5tb25pdG9ySWQgPSB1dWlkLnY0KCk7XG4gICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU1MDEubXNnKGBEZXBsb3lpbmcgJHt0aGlzLnN0YWNrTmFtZX1gLCB7XG4gICAgICBkZXBsb3ltZW50OiB0aGlzLm1vbml0b3JJZCxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgc3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgIHJlc291cmNlc1RvdGFsOiB0aGlzLnByb2dyZXNzTW9uaXRvci50b3RhbCxcbiAgICB9KSk7XG4gICAgdGhpcy5zY2hlZHVsZU5leHRUaWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RvcCgpIHtcbiAgICBjb25zdCBvbGRNb25pdG9ySWQgPSB0aGlzLm1vbml0b3JJZCE7XG4gICAgdGhpcy5tb25pdG9ySWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMudGlja1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aWNrVGltZXIpO1xuICAgIH1cblxuICAgIC8vIERvIGEgZmluYWwgcG9sbCBmb3IgYWxsIGV2ZW50cy4gVGhpcyBpcyB0byBoYW5kbGUgdGhlIHNpdHVhdGlvbiB3aGVyZSBEZXNjcmliZVN0YWNrU3RhdHVzXG4gICAgLy8gYWxyZWFkeSByZXR1cm5lZCBhbiBlcnJvciwgYnV0IHRoZSBtb25pdG9yIGhhc24ndCBzZWVuIGFsbCB0aGUgZXZlbnRzIHlldCBhbmQgd2UnZCBlbmRcbiAgICAvLyB1cCBub3QgcHJpbnRpbmcgdGhlIGZhaWx1cmUgcmVhc29uIHRvIHVzZXJzLlxuICAgIGF3YWl0IHRoaXMuZmluYWxQb2xsVG9FbmQob2xkTW9uaXRvcklkKTtcblxuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1NTAzLm1zZyhgQ29tcGxldGVkICR7dGhpcy5zdGFja05hbWV9YCwge1xuICAgICAgZGVwbG95bWVudDogb2xkTW9uaXRvcklkLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBzdGFja05hbWU6IHRoaXMuc3RhY2tOYW1lLFxuICAgICAgcmVzb3VyY2VzVG90YWw6IHRoaXMucHJvZ3Jlc3NNb25pdG9yLnRvdGFsLFxuICAgIH0pKTtcbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVOZXh0VGljaygpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy50aWNrKCksIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdGljaygpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvcklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVhZFByb21pc2UgPSB0aGlzLnJlYWROZXdFdmVudHModGhpcy5tb25pdG9ySWQpO1xuICAgICAgYXdhaXQgdGhpcy5yZWFkUHJvbWlzZTtcbiAgICAgIHRoaXMucmVhZFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYmVlbiBzdG9wKClwZWQgd2hpbGUgdGhlIG5ldHdvcmsgY2FsbCB3YXMgaW4gcHJvZ3Jlc3MuXG4gICAgICBpZiAoIXRoaXMubW9uaXRvcklkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9FNTUwMC5tc2coXG4gICAgICAgIHV0aWwuZm9ybWF0KCdFcnJvciBvY2N1cnJlZCB3aGlsZSBtb25pdG9yaW5nIHN0YWNrOiAlcycsIGUpLFxuICAgICAgICB7IGVycm9yOiBlIGFzIGFueSB9LFxuICAgICAgKSk7XG4gICAgfVxuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kTWV0YWRhdGFGb3IobG9naWNhbElkOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuc3RhY2subWFuaWZlc3Q/Lm1ldGFkYXRhO1xuICAgIGlmICghbG9naWNhbElkIHx8ICFtZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlTWV0YWRhdGEodGhpcy5zdGFjaywgbG9naWNhbElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGV2ZW50cyBmcm9tIHRoZSBzdGFjayBoaXN0b3J5XG4gICAqXG4gICAqIFRoZSBldmVudHMgYXJlIHJldHVybmVkIGluIHJldmVyc2UgY2hyb25vbG9naWNhbCBvcmRlcjsgd2UgY29udGludWUgdG8gdGhlIG5leHQgcGFnZSBpZiB3ZVxuICAgKiBzZWUgYSBuZXh0IHBhZ2UgYW5kIHRoZSBsYXN0IGV2ZW50IGluIHRoZSBwYWdlIGlzIG5ldyB0byB1cyAoYW5kIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cpLlxuICAgKiBoYXZlbid0IHNlZW4gdGhlIGZpbmFsIGV2ZW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlYWROZXdFdmVudHMobW9uaXRvcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwb2xsRXZlbnRzID0gYXdhaXQgdGhpcy5wb2xsZXIucG9sbCgpO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZUV2ZW50IG9mIHBvbGxFdmVudHMpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NNb25pdG9yLnByb2Nlc3MocmVzb3VyY2VFdmVudC5ldmVudCk7XG5cbiAgICAgIGNvbnN0IGFjdGl2aXR5OiBTdGFja0FjdGl2aXR5ID0ge1xuICAgICAgICBkZXBsb3ltZW50OiBtb25pdG9ySWQsXG4gICAgICAgIGV2ZW50OiByZXNvdXJjZUV2ZW50LmV2ZW50LFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5maW5kTWV0YWRhdGFGb3IocmVzb3VyY2VFdmVudC5ldmVudC5Mb2dpY2FsUmVzb3VyY2VJZCksXG4gICAgICAgIHByb2dyZXNzOiB0aGlzLnByb2dyZXNzTW9uaXRvci5wcm9ncmVzcyxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2hlY2tGb3JFcnJvcnMoYWN0aXZpdHkpO1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTU1MDIubXNnKHRoaXMuZm9ybWF0QWN0aXZpdHkoYWN0aXZpdHksIHRydWUpLCBhY3Rpdml0eSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgZmluYWwgcG9sbCB0byB0aGUgZW5kIGFuZCBmbHVzaCBvdXQgYWxsIGV2ZW50cyB0byB0aGUgcHJpbnRlclxuICAgKlxuICAgKiBGaW5pc2ggYW55IHBvbGwgY3VycmVudGx5IGluIHByb2dyZXNzLCB0aGVuIGRvIGEgZmluYWwgb25lIHVudGlsIHdlJ3ZlXG4gICAqIHJlYWNoZWQgdGhlIGxhc3QgcGFnZS5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmluYWxQb2xsVG9FbmQobW9uaXRvcklkOiBzdHJpbmcpIHtcbiAgICAvLyBJZiB3ZSB3ZXJlIGRvaW5nIGEgcG9sbCwgZmluaXNoIHRoYXQgZmlyc3QuIEl0IHdhcyBzdGFydGVkIGJlZm9yZVxuICAgIC8vIHRoZSBtb21lbnQgd2Ugd2VyZSBzdXJlIHdlIHdlcmVuJ3QgZ29pbmcgdG8gZ2V0IGFueSBuZXcgZXZlbnRzIGFueW1vcmVcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGRvIGEgbmV3IG9uZSBhbnl3YXkuIE5lZWQgdG8gd2FpdCBmb3IgdGhpcyBvbmUgdGhvdWdoXG4gICAgLy8gYmVjYXVzZSBvdXIgc3RhdGUgaXMgc2luZ2xlLXRocmVhZGVkLlxuICAgIGlmICh0aGlzLnJlYWRQcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlYWRQcm9taXNlO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucmVhZE5ld0V2ZW50cyhtb25pdG9ySWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYSBzdGFjayBhY3Rpdml0eSBpbnRvIGEgYmFzaWMgc3RyaW5nXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdEFjdGl2aXR5KGFjdGl2aXR5OiBTdGFja0FjdGl2aXR5LCBwcm9ncmVzczogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgY29uc3QgZXZlbnQgPSBhY3Rpdml0eS5ldmVudDtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGFjdGl2aXR5Lm1ldGFkYXRhO1xuXG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gbWV0YWRhdGEgPyBtZXRhZGF0YS5jb25zdHJ1Y3RQYXRoIDogZXZlbnQuTG9naWNhbFJlc291cmNlSWQgfHwgJyc7XG4gICAgY29uc3QgbG9naWNhbElkID0gcmVzb3VyY2VOYW1lICE9PSBldmVudC5Mb2dpY2FsUmVzb3VyY2VJZCA/IGAoJHtldmVudC5Mb2dpY2FsUmVzb3VyY2VJZH0pIGAgOiAnJztcblxuICAgIHJldHVybiB1dGlsLmZvcm1hdChcbiAgICAgICclcyB8ICVzJXMgfCAlcyB8ICVzIHwgJXMgJXMlcyVzJyxcbiAgICAgIGV2ZW50LlN0YWNrTmFtZSxcbiAgICAgIHByb2dyZXNzICE9PSBmYWxzZSA/IGAke2FjdGl2aXR5LnByb2dyZXNzLmZvcm1hdHRlZH0gfCBgIDogJycsXG4gICAgICBuZXcgRGF0ZShldmVudC5UaW1lc3RhbXAhKS50b0xvY2FsZVRpbWVTdHJpbmcoKSxcbiAgICAgIGV2ZW50LlJlc291cmNlU3RhdHVzIHx8ICcnLFxuICAgICAgZXZlbnQuUmVzb3VyY2VUeXBlLFxuICAgICAgcmVzb3VyY2VOYW1lLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgZXZlbnQuUmVzb3VyY2VTdGF0dXNSZWFzb24gPyBldmVudC5SZXNvdXJjZVN0YXR1c1JlYXNvbiA6ICcnLFxuICAgICAgbWV0YWRhdGE/LmVudHJ5LnRyYWNlID8gYFxcblxcdCR7bWV0YWRhdGEuZW50cnkudHJhY2Uuam9pbignXFxuXFx0XFxcXF8gJyl9YCA6ICcnLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yRXJyb3JzKGFjdGl2aXR5OiBTdGFja0FjdGl2aXR5KSB7XG4gICAgaWYgKHN0YWNrRXZlbnRIYXNFcnJvck1lc3NhZ2UoYWN0aXZpdHkuZXZlbnQuUmVzb3VyY2VTdGF0dXMgPz8gJycpKSB7XG4gICAgICBjb25zdCBpc0NhbmNlbGxlZCA9IChhY3Rpdml0eS5ldmVudC5SZXNvdXJjZVN0YXR1c1JlYXNvbiA/PyAnJykuaW5kZXhPZignY2FuY2VsbGVkJykgPiAtMTtcblxuICAgICAgLy8gQ2FuY2VsbGVkIGlzIG5vdCBhbiBpbnRlcmVzdGluZyBmYWlsdXJlIHJlYXNvbiwgbm9yIGlzIHRoZSBzdGFjayBtZXNzYWdlIChzdGFja1xuICAgICAgLy8gbWVzc2FnZSB3aWxsIGp1c3Qgc2F5IHNvbWV0aGluZyBsaWtlIFwic3RhY2sgZmFpbGVkIHRvIHVwZGF0ZVwiKVxuICAgICAgaWYgKCFpc0NhbmNlbGxlZCAmJiBhY3Rpdml0eS5ldmVudC5TdGFja05hbWUgIT09IGFjdGl2aXR5LmV2ZW50LkxvZ2ljYWxSZXNvdXJjZUlkKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2goYWN0aXZpdHkuZXZlbnQuUmVzb3VyY2VTdGF0dXNSZWFzb24gPz8gJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19