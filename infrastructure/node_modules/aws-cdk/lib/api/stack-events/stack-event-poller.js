"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackEventPoller = void 0;
const util_1 = require("../../util");
class StackEventPoller {
    constructor(cfn, props) {
        this.cfn = cfn;
        this.props = props;
        this.events = [];
        this.complete = false;
        this.eventIds = new Set();
        this.nestedStackPollers = {};
    }
    /**
     * From all accumulated events, return only the errors
     */
    get resourceErrors() {
        return this.events.filter((e) => e.event.ResourceStatus?.endsWith('_FAILED') && !e.isStackEvent);
    }
    /**
     * Poll for new stack events
     *
     * Will not return events older than events indicated by the constructor filters.
     *
     * Recurses into nested stacks, and returns events old-to-new.
     */
    async poll() {
        const events = await this.doPoll();
        // Also poll all nested stacks we're currently tracking
        for (const [logicalId, poller] of Object.entries(this.nestedStackPollers)) {
            events.push(...(await poller.poll()));
            if (poller.complete) {
                delete this.nestedStackPollers[logicalId];
            }
        }
        // Return what we have so far
        events.sort((a, b) => a.event.Timestamp.valueOf() - b.event.Timestamp.valueOf());
        this.events.push(...events);
        return events;
    }
    async doPoll() {
        const events = [];
        try {
            let nextToken;
            let finished = false;
            while (!finished) {
                const page = await this.cfn.describeStackEvents({ StackName: this.props.stackName, NextToken: nextToken });
                for (const event of page?.StackEvents ?? []) {
                    // Event from before we were interested in 'em
                    if (this.props.startTime !== undefined && event.Timestamp.valueOf() < this.props.startTime) {
                        return events;
                    }
                    // Already seen this one
                    if (this.eventIds.has(event.EventId)) {
                        return events;
                    }
                    this.eventIds.add(event.EventId);
                    // The events for the stack itself are also included next to events about resources; we can test for them in this way.
                    const isParentStackEvent = event.PhysicalResourceId === event.StackId;
                    if (isParentStackEvent && this.props.stackStatuses?.includes(event.ResourceStatus ?? '')) {
                        return events;
                    }
                    // Fresh event
                    const resEvent = {
                        event: event,
                        parentStackLogicalIds: this.props.parentStackLogicalIds ?? [],
                        isStackEvent: isParentStackEvent,
                    };
                    events.push(resEvent);
                    if (!isParentStackEvent &&
                        event.ResourceType === 'AWS::CloudFormation::Stack' &&
                        isStackBeginOperationState(event.ResourceStatus)) {
                        // If the event is not for `this` stack and has a physical resource Id, recursively call for events in the nested stack
                        this.trackNestedStack(event, [...(this.props.parentStackLogicalIds ?? []), event.LogicalResourceId ?? '']);
                    }
                    if (isParentStackEvent && isStackTerminalState(event.ResourceStatus)) {
                        this.complete = true;
                    }
                }
                nextToken = page?.NextToken;
                if (nextToken === undefined) {
                    finished = true;
                }
            }
        }
        catch (e) {
            if (!(e.name === 'ValidationError' && (0, util_1.formatErrorMessage)(e) === `Stack [${this.props.stackName}] does not exist`)) {
                throw e;
            }
        }
        return events;
    }
    /**
     * On the CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, DELETE_IN_PROGRESS event of a nested stack, poll the nested stack updates
     */
    trackNestedStack(event, parentStackLogicalIds) {
        const logicalId = event.LogicalResourceId;
        const physicalResourceId = event.PhysicalResourceId;
        // The CREATE_IN_PROGRESS event for a Nested Stack is emitted twice; first without a PhysicalResourceId
        // and then with. Ignore this event if we don't have that property yet.
        //
        // (At this point, I also don't trust that logicalId is always going to be there so validate that as well)
        if (!logicalId || !physicalResourceId) {
            return;
        }
        if (!this.nestedStackPollers[logicalId]) {
            this.nestedStackPollers[logicalId] = new StackEventPoller(this.cfn, {
                stackName: physicalResourceId,
                parentStackLogicalIds: parentStackLogicalIds,
                startTime: event.Timestamp.valueOf(),
            });
        }
    }
}
exports.StackEventPoller = StackEventPoller;
function isStackBeginOperationState(state) {
    return [
        'CREATE_IN_PROGRESS',
        'UPDATE_IN_PROGRESS',
        'DELETE_IN_PROGRESS',
        'UPDATE_ROLLBACK_IN_PROGRESS',
        'ROLLBACK_IN_PROGRESS',
    ].includes(state ?? '');
}
function isStackTerminalState(state) {
    return !(state ?? '').endsWith('_IN_PROGRESS');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhY2stZXZlbnQtcG9sbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic3RhY2stZXZlbnQtcG9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHFDQUFnRDtBQW1EaEQsTUFBYSxnQkFBZ0I7SUFPM0IsWUFDbUIsR0FBMEIsRUFDMUIsS0FBNEI7UUFENUIsUUFBRyxHQUFILEdBQUcsQ0FBdUI7UUFDMUIsVUFBSyxHQUFMLEtBQUssQ0FBdUI7UUFSL0IsV0FBTSxHQUFvQixFQUFFLENBQUM7UUFDdEMsYUFBUSxHQUFZLEtBQUssQ0FBQztRQUVoQixhQUFRLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUM3Qix1QkFBa0IsR0FBcUMsRUFBRSxDQUFDO0lBTTNFLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsY0FBYztRQUN2QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkcsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxJQUFJO1FBQ2YsTUFBTSxNQUFNLEdBQW9CLE1BQU0sSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXBELHVEQUF1RDtRQUN2RCxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDO1lBQzFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN0QyxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDcEIsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FB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QUVELFNBQVMsMEJBQTBCLENBQUMsS0FBeUI7SUFDM0QsT0FBTztRQUNMLG9CQUFvQjtRQUNwQixvQkFBb0I7UUFDcEIsb0JBQW9CO1FBQ3BCLDZCQUE2QjtRQUM3QixzQkFBc0I7S0FDdkIsQ0FBQyxRQUFRLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQzFCLENBQUM7QUFFRCxTQUFTLG9CQUFvQixDQUFDLEtBQXlCO0lBQ3JELE9BQU8sQ0FBQyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDakQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgU3RhY2tFdmVudCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgeyBmb3JtYXRFcnJvck1lc3NhZ2UgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkRm9ybWF0aW9uQ2xpZW50IH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrRXZlbnRQb2xsZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgc3RhY2sgdG8gcG9sbFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElEcyBvZiBwYXJlbnQgc3RhY2tzIG9mIHRoaXMgcmVzb3VyY2UsIGluIGNhc2Ugb2YgcmVzb3VyY2VzIGluIG5lc3RlZCBzdGFja3NcbiAgICovXG4gIHJlYWRvbmx5IHBhcmVudFN0YWNrTG9naWNhbElkcz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgZm9yIHRoZSBvbGRlc3QgZXZlbnQgd2UncmUgaW50ZXJlc3RlZCBpblxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFJlYWQgYWxsIGV2ZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgc3RhcnRUaW1lPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTdG9wIHJlYWRpbmcgd2hlbiB3ZSBzZWUgdGhlIHN0YWNrIGVudGVyaW5nIHRoaXMgc3RhdHVzXG4gICAqXG4gICAqIFNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSBgQ1JFQVRFX0lOX1BST0dSRVNTYCwgYFVQREFURV9JTl9QUk9HUkVTU2AsXG4gICAqIGBERUxFVEVfSU5fUFJPR1JFU1MsIGBST0xMQkFDS19JTl9QUk9HUkVTU2AuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gUmVhZCBhbGwgZXZlbnRzXG4gICAqL1xuICByZWFkb25seSBzdGFja1N0YXR1c2VzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgU3RhY2sgRXZlbnQgYXMgcmVjZWl2ZWQgZnJvbSBDbG91ZEZvcm1hdGlvblxuICAgKi9cbiAgcmVhZG9ubHkgZXZlbnQ6IFN0YWNrRXZlbnQ7XG5cbiAgLyoqXG4gICAqIElEcyBvZiBwYXJlbnQgc3RhY2tzIG9mIHRoZSByZXNvdXJjZSwgaW4gY2FzZSBvZiByZXNvdXJjZXMgaW4gbmVzdGVkIHN0YWNrc1xuICAgKi9cbiAgcmVhZG9ubHkgcGFyZW50U3RhY2tMb2dpY2FsSWRzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGV2ZW50IHJlZ2FyZHMgdGhlIHJvb3Qgc3RhY2tcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGlzU3RhY2tFdmVudD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja0V2ZW50UG9sbGVyIHtcbiAgcHVibGljIHJlYWRvbmx5IGV2ZW50czogUmVzb3VyY2VFdmVudFtdID0gW107XG4gIHB1YmxpYyBjb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgZXZlbnRJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBuZXN0ZWRTdGFja1BvbGxlcnM6IFJlY29yZDxzdHJpbmcsIFN0YWNrRXZlbnRQb2xsZXI+ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBTdGFja0V2ZW50UG9sbGVyUHJvcHMsXG4gICkge1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gYWxsIGFjY3VtdWxhdGVkIGV2ZW50cywgcmV0dXJuIG9ubHkgdGhlIGVycm9yc1xuICAgKi9cbiAgcHVibGljIGdldCByZXNvdXJjZUVycm9ycygpOiBSZXNvdXJjZUV2ZW50W10ge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5maWx0ZXIoKGUpID0+IGUuZXZlbnQuUmVzb3VyY2VTdGF0dXM/LmVuZHNXaXRoKCdfRkFJTEVEJykgJiYgIWUuaXNTdGFja0V2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2xsIGZvciBuZXcgc3RhY2sgZXZlbnRzXG4gICAqXG4gICAqIFdpbGwgbm90IHJldHVybiBldmVudHMgb2xkZXIgdGhhbiBldmVudHMgaW5kaWNhdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBmaWx0ZXJzLlxuICAgKlxuICAgKiBSZWN1cnNlcyBpbnRvIG5lc3RlZCBzdGFja3MsIGFuZCByZXR1cm5zIGV2ZW50cyBvbGQtdG8tbmV3LlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHBvbGwoKTogUHJvbWlzZTxSZXNvdXJjZUV2ZW50W10+IHtcbiAgICBjb25zdCBldmVudHM6IFJlc291cmNlRXZlbnRbXSA9IGF3YWl0IHRoaXMuZG9Qb2xsKCk7XG5cbiAgICAvLyBBbHNvIHBvbGwgYWxsIG5lc3RlZCBzdGFja3Mgd2UncmUgY3VycmVudGx5IHRyYWNraW5nXG4gICAgZm9yIChjb25zdCBbbG9naWNhbElkLCBwb2xsZXJdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMubmVzdGVkU3RhY2tQb2xsZXJzKSkge1xuICAgICAgZXZlbnRzLnB1c2goLi4uKGF3YWl0IHBvbGxlci5wb2xsKCkpKTtcbiAgICAgIGlmIChwb2xsZXIuY29tcGxldGUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMubmVzdGVkU3RhY2tQb2xsZXJzW2xvZ2ljYWxJZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHdoYXQgd2UgaGF2ZSBzbyBmYXJcbiAgICBldmVudHMuc29ydCgoYSwgYikgPT4gYS5ldmVudC5UaW1lc3RhbXAhLnZhbHVlT2YoKSAtIGIuZXZlbnQuVGltZXN0YW1wIS52YWx1ZU9mKCkpO1xuICAgIHRoaXMuZXZlbnRzLnB1c2goLi4uZXZlbnRzKTtcbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBkb1BvbGwoKTogUHJvbWlzZTxSZXNvdXJjZUV2ZW50W10+IHtcbiAgICBjb25zdCBldmVudHM6IFJlc291cmNlRXZlbnRbXSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBsZXQgbmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCFmaW5pc2hlZCkge1xuICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcy5jZm4uZGVzY3JpYmVTdGFja0V2ZW50cyh7IFN0YWNrTmFtZTogdGhpcy5wcm9wcy5zdGFja05hbWUsIE5leHRUb2tlbjogbmV4dFRva2VuIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHBhZ2U/LlN0YWNrRXZlbnRzID8/IFtdKSB7XG4gICAgICAgICAgLy8gRXZlbnQgZnJvbSBiZWZvcmUgd2Ugd2VyZSBpbnRlcmVzdGVkIGluICdlbVxuICAgICAgICAgIGlmICh0aGlzLnByb3BzLnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LlRpbWVzdGFtcCEudmFsdWVPZigpIDwgdGhpcy5wcm9wcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWxyZWFkeSBzZWVuIHRoaXMgb25lXG4gICAgICAgICAgaWYgKHRoaXMuZXZlbnRJZHMuaGFzKGV2ZW50LkV2ZW50SWQhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ldmVudElkcy5hZGQoZXZlbnQuRXZlbnRJZCEpO1xuXG4gICAgICAgICAgLy8gVGhlIGV2ZW50cyBmb3IgdGhlIHN0YWNrIGl0c2VsZiBhcmUgYWxzbyBpbmNsdWRlZCBuZXh0IHRvIGV2ZW50cyBhYm91dCByZXNvdXJjZXM7IHdlIGNhbiB0ZXN0IGZvciB0aGVtIGluIHRoaXMgd2F5LlxuICAgICAgICAgIGNvbnN0IGlzUGFyZW50U3RhY2tFdmVudCA9IGV2ZW50LlBoeXNpY2FsUmVzb3VyY2VJZCA9PT0gZXZlbnQuU3RhY2tJZDtcblxuICAgICAgICAgIGlmIChpc1BhcmVudFN0YWNrRXZlbnQgJiYgdGhpcy5wcm9wcy5zdGFja1N0YXR1c2VzPy5pbmNsdWRlcyhldmVudC5SZXNvdXJjZVN0YXR1cyA/PyAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRnJlc2ggZXZlbnRcbiAgICAgICAgICBjb25zdCByZXNFdmVudDogUmVzb3VyY2VFdmVudCA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHBhcmVudFN0YWNrTG9naWNhbElkczogdGhpcy5wcm9wcy5wYXJlbnRTdGFja0xvZ2ljYWxJZHMgPz8gW10sXG4gICAgICAgICAgICBpc1N0YWNrRXZlbnQ6IGlzUGFyZW50U3RhY2tFdmVudCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGV2ZW50cy5wdXNoKHJlc0V2ZW50KTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpc1BhcmVudFN0YWNrRXZlbnQgJiZcbiAgICAgICAgICAgICAgZXZlbnQuUmVzb3VyY2VUeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snICYmXG4gICAgICAgICAgICAgIGlzU3RhY2tCZWdpbk9wZXJhdGlvblN0YXRlKGV2ZW50LlJlc291cmNlU3RhdHVzKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIG5vdCBmb3IgYHRoaXNgIHN0YWNrIGFuZCBoYXMgYSBwaHlzaWNhbCByZXNvdXJjZSBJZCwgcmVjdXJzaXZlbHkgY2FsbCBmb3IgZXZlbnRzIGluIHRoZSBuZXN0ZWQgc3RhY2tcbiAgICAgICAgICAgIHRoaXMudHJhY2tOZXN0ZWRTdGFjayhldmVudCwgWy4uLih0aGlzLnByb3BzLnBhcmVudFN0YWNrTG9naWNhbElkcyA/PyBbXSksIGV2ZW50LkxvZ2ljYWxSZXNvdXJjZUlkID8/ICcnXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzUGFyZW50U3RhY2tFdmVudCAmJiBpc1N0YWNrVGVybWluYWxTdGF0ZShldmVudC5SZXNvdXJjZVN0YXR1cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRUb2tlbiA9IHBhZ2U/Lk5leHRUb2tlbjtcbiAgICAgICAgaWYgKG5leHRUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoIShlLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InICYmIGZvcm1hdEVycm9yTWVzc2FnZShlKSA9PT0gYFN0YWNrIFske3RoaXMucHJvcHMuc3RhY2tOYW1lfV0gZG9lcyBub3QgZXhpc3RgKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICAvKipcbiAgICogT24gdGhlIENSRUFURV9JTl9QUk9HUkVTUywgVVBEQVRFX0lOX1BST0dSRVNTLCBERUxFVEVfSU5fUFJPR1JFU1MgZXZlbnQgb2YgYSBuZXN0ZWQgc3RhY2ssIHBvbGwgdGhlIG5lc3RlZCBzdGFjayB1cGRhdGVzXG4gICAqL1xuICBwcml2YXRlIHRyYWNrTmVzdGVkU3RhY2soZXZlbnQ6IFN0YWNrRXZlbnQsIHBhcmVudFN0YWNrTG9naWNhbElkczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBsb2dpY2FsSWQgPSBldmVudC5Mb2dpY2FsUmVzb3VyY2VJZDtcbiAgICBjb25zdCBwaHlzaWNhbFJlc291cmNlSWQgPSBldmVudC5QaHlzaWNhbFJlc291cmNlSWQ7XG5cbiAgICAvLyBUaGUgQ1JFQVRFX0lOX1BST0dSRVNTIGV2ZW50IGZvciBhIE5lc3RlZCBTdGFjayBpcyBlbWl0dGVkIHR3aWNlOyBmaXJzdCB3aXRob3V0IGEgUGh5c2ljYWxSZXNvdXJjZUlkXG4gICAgLy8gYW5kIHRoZW4gd2l0aC4gSWdub3JlIHRoaXMgZXZlbnQgaWYgd2UgZG9uJ3QgaGF2ZSB0aGF0IHByb3BlcnR5IHlldC5cbiAgICAvL1xuICAgIC8vIChBdCB0aGlzIHBvaW50LCBJIGFsc28gZG9uJ3QgdHJ1c3QgdGhhdCBsb2dpY2FsSWQgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHRoZXJlIHNvIHZhbGlkYXRlIHRoYXQgYXMgd2VsbClcbiAgICBpZiAoIWxvZ2ljYWxJZCB8fCAhcGh5c2ljYWxSZXNvdXJjZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5lc3RlZFN0YWNrUG9sbGVyc1tsb2dpY2FsSWRdKSB7XG4gICAgICB0aGlzLm5lc3RlZFN0YWNrUG9sbGVyc1tsb2dpY2FsSWRdID0gbmV3IFN0YWNrRXZlbnRQb2xsZXIodGhpcy5jZm4sIHtcbiAgICAgICAgc3RhY2tOYW1lOiBwaHlzaWNhbFJlc291cmNlSWQsXG4gICAgICAgIHBhcmVudFN0YWNrTG9naWNhbElkczogcGFyZW50U3RhY2tMb2dpY2FsSWRzLFxuICAgICAgICBzdGFydFRpbWU6IGV2ZW50LlRpbWVzdGFtcCEudmFsdWVPZigpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tCZWdpbk9wZXJhdGlvblN0YXRlKHN0YXRlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIFtcbiAgICAnQ1JFQVRFX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX0lOX1BST0dSRVNTJyxcbiAgICAnREVMRVRFX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX1JPTExCQUNLX0lOX1BST0dSRVNTJyxcbiAgICAnUk9MTEJBQ0tfSU5fUFJPR1JFU1MnLFxuICBdLmluY2x1ZGVzKHN0YXRlID8/ICcnKTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja1Rlcm1pbmFsU3RhdGUoc3RhdGU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gIShzdGF0ZSA/PyAnJykuZW5kc1dpdGgoJ19JTl9QUk9HUkVTUycpO1xufVxuIl19